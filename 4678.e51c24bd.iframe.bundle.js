(self.webpackChunkgutenberg=self.webpackChunkgutenberg||[]).push([[4678],{"./node_modules/sprintf-js/src/sprintf.js":function(module,exports,__webpack_require__){var __WEBPACK_AMD_DEFINE_RESULT__;!function(){"use strict";var re={not_string:/[^s]/,not_bool:/[^t]/,not_type:/[^T]/,not_primitive:/[^v]/,number:/[diefg]/,numeric_arg:/[bcdiefguxX]/,json:/[j]/,not_json:/[^j]/,text:/^[^\x25]+/,modulo:/^\x25{2}/,placeholder:/^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,key:/^([a-z_][a-z_\d]*)/i,key_access:/^\.([a-z_][a-z_\d]*)/i,index_access:/^\[(\d+)\]/,sign:/^[\+\-]/};function sprintf(key){return sprintf_format(sprintf_parse(key),arguments)}function vsprintf(fmt,argv){return sprintf.apply(null,[fmt].concat(argv||[]))}function sprintf_format(parse_tree,argv){var arg,i,k,match,pad,pad_character,pad_length,is_positive,sign,cursor=1,tree_length=parse_tree.length,output="";for(i=0;i<tree_length;i++)if("string"==typeof parse_tree[i])output+=parse_tree[i];else if(Array.isArray(parse_tree[i])){if((match=parse_tree[i])[2])for(arg=argv[cursor],k=0;k<match[2].length;k++){if(!arg.hasOwnProperty(match[2][k]))throw new Error(sprintf('[sprintf] property "%s" does not exist',match[2][k]));arg=arg[match[2][k]]}else arg=match[1]?argv[match[1]]:argv[cursor++];if(re.not_type.test(match[8])&&re.not_primitive.test(match[8])&&arg instanceof Function&&(arg=arg()),re.numeric_arg.test(match[8])&&"number"!=typeof arg&&isNaN(arg))throw new TypeError(sprintf("[sprintf] expecting number but found %T",arg));switch(re.number.test(match[8])&&(is_positive=arg>=0),match[8]){case"b":arg=parseInt(arg,10).toString(2);break;case"c":arg=String.fromCharCode(parseInt(arg,10));break;case"d":case"i":arg=parseInt(arg,10);break;case"j":arg=JSON.stringify(arg,null,match[6]?parseInt(match[6]):0);break;case"e":arg=match[7]?parseFloat(arg).toExponential(match[7]):parseFloat(arg).toExponential();break;case"f":arg=match[7]?parseFloat(arg).toFixed(match[7]):parseFloat(arg);break;case"g":arg=match[7]?String(Number(arg.toPrecision(match[7]))):parseFloat(arg);break;case"o":arg=(parseInt(arg,10)>>>0).toString(8);break;case"s":arg=String(arg),arg=match[7]?arg.substring(0,match[7]):arg;break;case"t":arg=String(!!arg),arg=match[7]?arg.substring(0,match[7]):arg;break;case"T":arg=Object.prototype.toString.call(arg).slice(8,-1).toLowerCase(),arg=match[7]?arg.substring(0,match[7]):arg;break;case"u":arg=parseInt(arg,10)>>>0;break;case"v":arg=arg.valueOf(),arg=match[7]?arg.substring(0,match[7]):arg;break;case"x":arg=(parseInt(arg,10)>>>0).toString(16);break;case"X":arg=(parseInt(arg,10)>>>0).toString(16).toUpperCase()}re.json.test(match[8])?output+=arg:(!re.number.test(match[8])||is_positive&&!match[3]?sign="":(sign=is_positive?"+":"-",arg=arg.toString().replace(re.sign,"")),pad_character=match[4]?"0"===match[4]?"0":match[4].charAt(1):" ",pad_length=match[6]-(sign+arg).length,pad=match[6]&&pad_length>0?pad_character.repeat(pad_length):"",output+=match[5]?sign+arg+pad:"0"===pad_character?sign+pad+arg:pad+sign+arg)}return output}var sprintf_cache=Object.create(null);function sprintf_parse(fmt){if(sprintf_cache[fmt])return sprintf_cache[fmt];for(var match,_fmt=fmt,parse_tree=[],arg_names=0;_fmt;){if(null!==(match=re.text.exec(_fmt)))parse_tree.push(match[0]);else if(null!==(match=re.modulo.exec(_fmt)))parse_tree.push("%");else{if(null===(match=re.placeholder.exec(_fmt)))throw new SyntaxError("[sprintf] unexpected placeholder");if(match[2]){arg_names|=1;var field_list=[],replacement_field=match[2],field_match=[];if(null===(field_match=re.key.exec(replacement_field)))throw new SyntaxError("[sprintf] failed to parse named argument key");for(field_list.push(field_match[1]);""!==(replacement_field=replacement_field.substring(field_match[0].length));)if(null!==(field_match=re.key_access.exec(replacement_field)))field_list.push(field_match[1]);else{if(null===(field_match=re.index_access.exec(replacement_field)))throw new SyntaxError("[sprintf] failed to parse named argument key");field_list.push(field_match[1])}match[2]=field_list}else arg_names|=2;if(3===arg_names)throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");parse_tree.push(match)}_fmt=_fmt.substring(match[0].length)}return sprintf_cache[fmt]=parse_tree}exports.sprintf=sprintf,exports.vsprintf=vsprintf,"undefined"!=typeof window&&(window.sprintf=sprintf,window.vsprintf=vsprintf,void 0===(__WEBPACK_AMD_DEFINE_RESULT__=function(){return{sprintf:sprintf,vsprintf:vsprintf}}.call(exports,__webpack_require__,exports,module))||(module.exports=__WEBPACK_AMD_DEFINE_RESULT__))}()},"./node_modules/tannin/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";var PRECEDENCE,OPENERS,TERMINATORS,PATTERN;__webpack_require__.d(__webpack_exports__,{Z:function(){return Tannin}}),PRECEDENCE={"(":9,"!":8,"*":7,"/":7,"%":7,"+":6,"-":6,"<":5,"<=":5,">":5,">=":5,"==":4,"!=":4,"&&":3,"||":2,"?":1,"?:":1},OPENERS=["(","?"],TERMINATORS={")":["("],":":["?","?:"]},PATTERN=/<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;var OPERATORS={"!":function(a){return!a},"*":function(a,b){return a*b},"/":function(a,b){return a/b},"%":function(a,b){return a%b},"+":function(a,b){return a+b},"-":function(a,b){return a-b},"<":function(a,b){return a<b},"<=":function(a,b){return a<=b},">":function(a,b){return a>b},">=":function(a,b){return a>=b},"==":function(a,b){return a===b},"!=":function(a,b){return a!==b},"&&":function(a,b){return a&&b},"||":function(a,b){return a||b},"?:":function(a,b,c){if(a)throw b;return c}};function compile(expression){var terms=function postfix(expression){for(var match,operator,term,element,terms=[],stack=[];match=expression.match(PATTERN);){for(operator=match[0],(term=expression.substr(0,match.index).trim())&&terms.push(term);element=stack.pop();){if(TERMINATORS[operator]){if(TERMINATORS[operator][0]===element){operator=TERMINATORS[operator][1]||operator;break}}else if(OPENERS.indexOf(element)>=0||PRECEDENCE[element]<PRECEDENCE[operator]){stack.push(element);break}terms.push(element)}TERMINATORS[operator]||stack.push(operator),expression=expression.substr(match.index+operator.length)}return(expression=expression.trim())&&terms.push(expression),terms.concat(stack.reverse())}(expression);return function(variables){return function evaluate(postfix,variables){var i,j,args,getOperatorResult,term,value,stack=[];for(i=0;i<postfix.length;i++){if(term=postfix[i],getOperatorResult=OPERATORS[term]){for(j=getOperatorResult.length,args=Array(j);j--;)args[j]=stack.pop();try{value=getOperatorResult.apply(null,args)}catch(earlyReturn){return earlyReturn}}else value=variables.hasOwnProperty(term)?variables[term]:+term;stack.push(value)}return stack[0]}(terms,variables)}}var DEFAULT_OPTIONS={contextDelimiter:"",onMissingKey:null};function Tannin(data,options){var key;for(key in this.data=data,this.pluralForms={},this.options={},DEFAULT_OPTIONS)this.options[key]=void 0!==options&&key in options?options[key]:DEFAULT_OPTIONS[key]}Tannin.prototype.getPluralForm=function(domain,n){var config,plural,pf,getPluralForm=this.pluralForms[domain];return getPluralForm||("function"!=typeof(pf=(config=this.data[domain][""])["Plural-Forms"]||config["plural-forms"]||config.plural_forms)&&(plural=function getPluralExpression(pf){var parts,i,part;for(parts=pf.split(";"),i=0;i<parts.length;i++)if(0===(part=parts[i].trim()).indexOf("plural="))return part.substr(7)}(config["Plural-Forms"]||config["plural-forms"]||config.plural_forms),pf=function pluralForms(expression){var evaluate=compile(expression);return function(n){return+evaluate({n:n})}}(plural)),getPluralForm=this.pluralForms[domain]=pf),getPluralForm(n)},Tannin.prototype.dcnpgettext=function(domain,context,singular,plural,n){var index,key,entry;return index=void 0===n?0:this.getPluralForm(domain,n),key=singular,context&&(key=context+this.options.contextDelimiter+singular),(entry=this.data[domain][key])&&entry[index]?entry[index]:(this.options.onMissingKey&&this.options.onMissingKey(singular,domain),0===index?singular:plural)}},"./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{p:function(){return LayoutGroupContext}});const LayoutGroupContext=(0,__webpack_require__("./node_modules/react/index.js").createContext)({})},"./node_modules/framer-motion/dist/es/context/PresenceContext.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{O:function(){return PresenceContext}});const PresenceContext=(0,__webpack_require__("./node_modules/react/index.js").createContext)(null)},"./node_modules/framer-motion/dist/es/render/dom/motion.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{E:function(){return motion}});var react=__webpack_require__("./node_modules/react/index.js");const MotionConfigContext=(0,react.createContext)({transformPagePoint:p=>p,isStatic:!1,reducedMotion:"never"}),MotionContext=(0,react.createContext)({});var context_PresenceContext=__webpack_require__("./node_modules/framer-motion/dist/es/context/PresenceContext.mjs"),use_isomorphic_effect=__webpack_require__("./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs");const LazyContext=(0,react.createContext)({strict:!1});function useVisualElement(Component,visualState,props,createVisualElement){const parent=function useVisualElementContext(){return(0,react.useContext)(MotionContext).visualElement}(),lazyContext=(0,react.useContext)(LazyContext),presenceContext=(0,react.useContext)(context_PresenceContext.O),reducedMotionConfig=(0,react.useContext)(MotionConfigContext).reducedMotion,visualElementRef=(0,react.useRef)();createVisualElement=createVisualElement||lazyContext.renderer,!visualElementRef.current&&createVisualElement&&(visualElementRef.current=createVisualElement(Component,{visualState:visualState,parent:parent,props:props,presenceId:presenceContext?presenceContext.id:void 0,blockInitialAnimation:!!presenceContext&&!1===presenceContext.initial,reducedMotionConfig:reducedMotionConfig}));const visualElement=visualElementRef.current;return(0,use_isomorphic_effect.L)((()=>{visualElement&&visualElement.render()})),(0,react.useEffect)((()=>{visualElement&&visualElement.animationState&&visualElement.animationState.animateChanges()})),(0,use_isomorphic_effect.L)((()=>()=>visualElement&&visualElement.notify("Unmount")),[]),visualElement}function isRefObject(ref){return"object"==typeof ref&&Object.prototype.hasOwnProperty.call(ref,"current")}function isVariantLabel(v){return"string"==typeof v||Array.isArray(v)}function isAnimationControls(v){return"object"==typeof v&&"function"==typeof v.start}const variantProps=["initial","animate","exit","whileHover","whileDrag","whileTap","whileFocus","whileInView"];function isControllingVariants(props){return isAnimationControls(props.animate)||variantProps.some((name=>isVariantLabel(props[name])))}function isVariantNode(props){return Boolean(isControllingVariants(props)||props.variants)}function useCreateMotionContext(props){const{initial:initial,animate:animate}=function getCurrentTreeVariants(props,context){if(isControllingVariants(props)){const{initial:initial,animate:animate}=props;return{initial:!1===initial||isVariantLabel(initial)?initial:void 0,animate:isVariantLabel(animate)?animate:void 0}}return!1!==props.inherit?context:{}}(props,(0,react.useContext)(MotionContext));return(0,react.useMemo)((()=>({initial:initial,animate:animate})),[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)])}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(" "):prop}const createDefinition=propNames=>({isEnabled:props=>propNames.some((name=>!!props[name]))}),featureDefinitions={measureLayout:createDefinition(["layout","layoutId","drag"]),animation:createDefinition(["animate","exit","variants","whileHover","whileTap","whileFocus","whileDrag","whileInView"]),exit:createDefinition(["exit"]),drag:createDefinition(["drag","dragControls"]),focus:createDefinition(["whileFocus"]),hover:createDefinition(["whileHover","onHoverStart","onHoverEnd"]),tap:createDefinition(["whileTap","onTap","onTapStart","onTapCancel"]),pan:createDefinition(["onPan","onPanStart","onPanSessionStart","onPanEnd"]),inView:createDefinition(["whileInView","onViewportEnter","onViewportLeave"])};var is_browser=__webpack_require__("./node_modules/framer-motion/dist/es/utils/is-browser.mjs"),use_constant=__webpack_require__("./node_modules/framer-motion/dist/es/utils/use-constant.mjs");const globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1};let id=1;var LayoutGroupContext=__webpack_require__("./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs");class VisualElementHandler extends react.Component{getSnapshotBeforeUpdate(){const{visualElement:visualElement,props:props}=this.props;return visualElement&&visualElement.setProps(props),null}componentDidUpdate(){}render(){return this.props.children}}const SwitchLayoutGroupContext=(0,react.createContext)({}),motionComponentSymbol=Symbol.for("motionComponentSymbol");function motion_createMotionComponent({preloadedFeatures:preloadedFeatures,createVisualElement:createVisualElement,projectionNodeConstructor:projectionNodeConstructor,useRender:useRender,useVisualState:useVisualState,Component:Component}){preloadedFeatures&&function loadFeatures(features){for(const key in features)"projectionNodeConstructor"===key?featureDefinitions.projectionNodeConstructor=features[key]:featureDefinitions[key].Component=features[key]}(preloadedFeatures);const ForwardRefComponent=(0,react.forwardRef)((function MotionComponent(props,externalRef){const configAndProps={...(0,react.useContext)(MotionConfigContext),...props,layoutId:useLayoutId(props)},{isStatic:isStatic}=configAndProps;let features=null;const context=useCreateMotionContext(props),projectionId=isStatic?void 0:function useProjectionId(){return(0,use_constant.h)((()=>{if(globalProjectionState.hasEverUpdated)return id++}))}(),visualState=useVisualState(props,isStatic);if(!isStatic&&is_browser.j){context.visualElement=useVisualElement(Component,visualState,configAndProps,createVisualElement);const lazyStrictMode=(0,react.useContext)(LazyContext).strict,initialLayoutGroupConfig=(0,react.useContext)(SwitchLayoutGroupContext);context.visualElement&&(features=context.visualElement.loadFeatures(configAndProps,lazyStrictMode,preloadedFeatures,projectionId,projectionNodeConstructor||featureDefinitions.projectionNodeConstructor,initialLayoutGroupConfig))}return react.createElement(VisualElementHandler,{visualElement:context.visualElement,props:configAndProps},features,react.createElement(MotionContext.Provider,{value:context},useRender(Component,props,projectionId,function useMotionRef(visualState,visualElement,externalRef){return(0,react.useCallback)((instance=>{instance&&visualState.mount&&visualState.mount(instance),visualElement&&(instance?visualElement.mount(instance):visualElement.unmount()),externalRef&&("function"==typeof externalRef?externalRef(instance):isRefObject(externalRef)&&(externalRef.current=instance))}),[visualElement])}(visualState,context.visualElement,externalRef),visualState,isStatic,context.visualElement)))}));return ForwardRefComponent[motionComponentSymbol]=Component,ForwardRefComponent}function useLayoutId({layoutId:layoutId}){const layoutGroupId=(0,react.useContext)(LayoutGroupContext.p).id;return layoutGroupId&&void 0!==layoutId?layoutGroupId+"-"+layoutId:layoutId}function createMotionProxy(createConfig){function custom(Component,customMotionComponentConfig={}){return motion_createMotionComponent(createConfig(Component,customMotionComponentConfig))}if("undefined"==typeof Proxy)return custom;const componentCache=new Map;return new Proxy(custom,{get:(_target,key)=>(componentCache.has(key)||componentCache.set(key,custom(key)),componentCache.get(key))})}const lowercaseSVGElements=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","text","tspan","use","view"];function isSVGComponent(Component){return"string"==typeof Component&&!Component.includes("-")&&!!(lowercaseSVGElements.indexOf(Component)>-1||/[A-Z]/.test(Component))}const scaleCorrectors={};const transformPropOrder=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],transformProps=new Set(transformPropOrder);function isForcedMotionValue(key,{layout:layout,layoutId:layoutId}){return transformProps.has(key)||key.startsWith("origin")||(layout||void 0!==layoutId)&&(!!scaleCorrectors[key]||"opacity"===key)}const isMotionValue=value=>!!(null==value?void 0:value.getVelocity),translateAlias={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},sortTransformProps=(a,b)=>transformPropOrder.indexOf(a)-transformPropOrder.indexOf(b);function isCSSVariable(key){return key.startsWith("--")}const getValueAsType=(value,type)=>type&&"number"==typeof value?type.transform(value):value,clamp=(min,max)=>v=>Math.max(Math.min(v,max),min),sanitize=v=>v%1?Number(v.toFixed(5)):v,floatRegex=/(-)?([\d]*\.?[\d])+/g,colorRegex=/(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,singleColorRegex=/^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function isString(v){return"string"==typeof v}const createUnitType=unit=>({test:v=>isString(v)&&v.endsWith(unit)&&1===v.split(" ").length,parse:parseFloat,transform:v=>`${v}${unit}`}),degrees=createUnitType("deg"),percent=createUnitType("%"),px=createUnitType("px"),vh=createUnitType("vh"),vw=createUnitType("vw"),progressPercentage=Object.assign(Object.assign({},percent),{parse:v=>percent.parse(v)/100,transform:v=>percent.transform(100*v)}),number={test:v=>"number"==typeof v,parse:parseFloat,transform:v=>v},alpha=Object.assign(Object.assign({},number),{transform:clamp(0,1)}),scale=Object.assign(Object.assign({},number),{default:1}),type_int_int={...number,transform:Math.round},numberValueTypes={borderWidth:px,borderTopWidth:px,borderRightWidth:px,borderBottomWidth:px,borderLeftWidth:px,borderRadius:px,radius:px,borderTopLeftRadius:px,borderTopRightRadius:px,borderBottomRightRadius:px,borderBottomLeftRadius:px,width:px,maxWidth:px,height:px,maxHeight:px,size:px,top:px,right:px,bottom:px,left:px,padding:px,paddingTop:px,paddingRight:px,paddingBottom:px,paddingLeft:px,margin:px,marginTop:px,marginRight:px,marginBottom:px,marginLeft:px,rotate:degrees,rotateX:degrees,rotateY:degrees,rotateZ:degrees,scale:scale,scaleX:scale,scaleY:scale,scaleZ:scale,skew:degrees,skewX:degrees,skewY:degrees,distance:px,translateX:px,translateY:px,translateZ:px,x:px,y:px,z:px,perspective:px,transformPerspective:px,opacity:alpha,originX:progressPercentage,originY:progressPercentage,originZ:px,zIndex:type_int_int,fillOpacity:alpha,strokeOpacity:alpha,numOctaves:type_int_int};function buildHTMLStyles(state,latestValues,options,transformTemplate){const{style:style,vars:vars,transform:transform,transformKeys:transformKeys,transformOrigin:transformOrigin}=state;transformKeys.length=0;let hasTransform=!1,hasTransformOrigin=!1,transformIsNone=!0;for(const key in latestValues){const value=latestValues[key];if(isCSSVariable(key)){vars[key]=value;continue}const valueType=numberValueTypes[key],valueAsType=getValueAsType(value,valueType);if(transformProps.has(key)){if(hasTransform=!0,transform[key]=valueAsType,transformKeys.push(key),!transformIsNone)continue;value!==(valueType.default||0)&&(transformIsNone=!1)}else key.startsWith("origin")?(hasTransformOrigin=!0,transformOrigin[key]=valueAsType):style[key]=valueAsType}if(latestValues.transform||(hasTransform||transformTemplate?style.transform=function buildTransform({transform:transform,transformKeys:transformKeys},{enableHardwareAcceleration:enableHardwareAcceleration=!0,allowTransformNone:allowTransformNone=!0},transformIsDefault,transformTemplate){let transformString="";transformKeys.sort(sortTransformProps);for(const key of transformKeys)transformString+=`${translateAlias[key]||key}(${transform[key]}) `;return enableHardwareAcceleration&&!transform.z&&(transformString+="translateZ(0)"),transformString=transformString.trim(),transformTemplate?transformString=transformTemplate(transform,transformIsDefault?"":transformString):allowTransformNone&&transformIsDefault&&(transformString="none"),transformString}(state,options,transformIsNone,transformTemplate):style.transform&&(style.transform="none")),hasTransformOrigin){const{originX:originX="50%",originY:originY="50%",originZ:originZ=0}=transformOrigin;style.transformOrigin=`${originX} ${originY} ${originZ}`}}const createHtmlRenderState=()=>({style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{}});function copyRawValuesOnly(target,source,props){for(const key in source)isMotionValue(source[key])||isForcedMotionValue(key,props)||(target[key]=source[key])}function useStyle(props,visualState,isStatic){const style={};return copyRawValuesOnly(style,props.style||{},props),Object.assign(style,function useInitialMotionValues({transformTemplate:transformTemplate},visualState,isStatic){return(0,react.useMemo)((()=>{const state={style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{}};return buildHTMLStyles(state,visualState,{enableHardwareAcceleration:!isStatic},transformTemplate),Object.assign({},state.vars,state.style)}),[visualState])}(props,visualState,isStatic)),props.transformValues?props.transformValues(style):style}function useHTMLProps(props,visualState,isStatic){const htmlProps={},style=useStyle(props,visualState,isStatic);return props.drag&&!1!==props.dragListener&&(htmlProps.draggable=!1,style.userSelect=style.WebkitUserSelect=style.WebkitTouchCallout="none",style.touchAction=!0===props.drag?"none":"pan-"+("x"===props.drag?"y":"x")),htmlProps.style=style,htmlProps}const validMotionProps=new Set(["initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","layout","layoutId","layoutDependency","onLayoutAnimationStart","onLayoutAnimationComplete","onLayoutMeasure","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","drag","dragControls","dragListener","dragConstraints","dragDirectionLock","dragSnapToOrigin","_dragX","_dragY","dragElastic","dragMomentum","dragPropagation","dragTransition","onHoverStart","onHoverEnd","layoutScroll","whileInView","onViewportEnter","onViewportLeave","viewport","whileTap","onTap","onTapStart","onTapCancel","animate","exit","variants","whileHover","whileTap","whileFocus","whileDrag","whileInView","onPan","onPanStart","onPanSessionStart","onPanEnd"]);function isValidMotionProp(key){return validMotionProps.has(key)}let shouldForward=key=>!isValidMotionProp(key);try{!function loadExternalIsValidProp(isValidProp){isValidProp&&(shouldForward=key=>key.startsWith("on")?!isValidMotionProp(key):isValidProp(key))}(require("@emotion/is-prop-valid").default)}catch(_a){}function calcOrigin(origin,offset,size){return"string"==typeof origin?origin:px.transform(offset+size*origin)}const dashKeys={offset:"stroke-dashoffset",array:"stroke-dasharray"},camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"};function buildSVGAttrs(state,{attrX:attrX,attrY:attrY,originX:originX,originY:originY,pathLength:pathLength,pathSpacing:pathSpacing=1,pathOffset:pathOffset=0,...latest},options,transformTemplate){buildHTMLStyles(state,latest,options,transformTemplate),state.attrs=state.style,state.style={};const{attrs:attrs,style:style,dimensions:dimensions}=state;attrs.transform&&(dimensions&&(style.transform=attrs.transform),delete attrs.transform),dimensions&&(void 0!==originX||void 0!==originY||style.transform)&&(style.transformOrigin=function calcSVGTransformOrigin(dimensions,originX,originY){return`${calcOrigin(originX,dimensions.x,dimensions.width)} ${calcOrigin(originY,dimensions.y,dimensions.height)}`}(dimensions,void 0!==originX?originX:.5,void 0!==originY?originY:.5)),void 0!==attrX&&(attrs.x=attrX),void 0!==attrY&&(attrs.y=attrY),void 0!==pathLength&&function buildSVGPath(attrs,length,spacing=1,offset=0,useDashCase=!0){attrs.pathLength=1;const keys=useDashCase?dashKeys:camelKeys;attrs[keys.offset]=px.transform(-offset);const pathLength=px.transform(length),pathSpacing=px.transform(spacing);attrs[keys.array]=`${pathLength} ${pathSpacing}`}(attrs,pathLength,pathSpacing,pathOffset,!1)}const createSvgRenderState=()=>({style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{},attrs:{}});function useSVGProps(props,visualState){const visualProps=(0,react.useMemo)((()=>{const state={style:{},transform:{},transformKeys:[],transformOrigin:{},vars:{},attrs:{}};return buildSVGAttrs(state,visualState,{enableHardwareAcceleration:!1},props.transformTemplate),{...state.attrs,style:{...state.style}}}),[visualState]);if(props.style){const rawStyles={};copyRawValuesOnly(rawStyles,props.style,props),visualProps.style={...rawStyles,...visualProps.style}}return visualProps}function createUseRender(forwardMotionProps=!1){return(Component,props,projectionId,ref,{latestValues:latestValues},isStatic)=>{const visualProps=(isSVGComponent(Component)?useSVGProps:useHTMLProps)(props,latestValues,isStatic),filteredProps=function filterProps(props,isDom,forwardMotionProps){const filteredProps={};for(const key in props)(shouldForward(key)||!0===forwardMotionProps&&isValidMotionProp(key)||!isDom&&!isValidMotionProp(key)||props.draggable&&key.startsWith("onDrag"))&&(filteredProps[key]=props[key]);return filteredProps}(props,"string"==typeof Component,forwardMotionProps),elementProps={...filteredProps,...visualProps,ref:ref};return projectionId&&(elementProps["data-projection-id"]=projectionId),(0,react.createElement)(Component,elementProps)}}const camelToDash=str=>str.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();function renderHTML(element,{style:style,vars:vars},styleProp,projection){Object.assign(element.style,style,projection&&projection.getProjectionStyles(styleProp));for(const key in vars)element.style.setProperty(key,vars[key])}const camelCaseAttributes=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength"]);function renderSVG(element,renderState,_styleProp,projection){renderHTML(element,renderState,void 0,projection);for(const key in renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?key:camelToDash(key),renderState.attrs[key])}function scrapeMotionValuesFromProps(props){const{style:style}=props,newValues={};for(const key in style)(isMotionValue(style[key])||isForcedMotionValue(key,props))&&(newValues[key]=style[key]);return newValues}function scrape_motion_values_scrapeMotionValuesFromProps(props){const newValues=scrapeMotionValuesFromProps(props);for(const key in props)if(isMotionValue(props[key])){newValues["x"===key||"y"===key?"attr"+key.toUpperCase():key]=props[key]}return newValues}function resolveVariantFromProps(props,definition,custom,currentValues={},currentVelocity={}){return"function"==typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity)),"string"==typeof definition&&(definition=props.variants&&props.variants[definition]),"function"==typeof definition&&(definition=definition(void 0!==custom?custom:props.custom,currentValues,currentVelocity)),definition}const isKeyframesTarget=v=>Array.isArray(v),resolveFinalValueInKeyframes=v=>isKeyframesTarget(v)?v[v.length-1]||0:v;function resolveMotionValue(value){const unwrappedValue=isMotionValue(value)?value.get():value;return v=unwrappedValue,Boolean(v&&"object"==typeof v&&v.mix&&v.toValue)?unwrappedValue.toValue():unwrappedValue;var v}const makeUseVisualState=config=>(props,isStatic)=>{const context=(0,react.useContext)(MotionContext),presenceContext=(0,react.useContext)(context_PresenceContext.O),make=()=>function makeState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps,createRenderState:createRenderState,onMount:onMount},props,context,presenceContext){const state={latestValues:makeLatestValues(props,context,presenceContext,scrapeMotionValuesFromProps),renderState:createRenderState()};return onMount&&(state.mount=instance=>onMount(props,instance,state)),state}(config,props,context,presenceContext);return isStatic?make():(0,use_constant.h)(make)};function makeLatestValues(props,context,presenceContext,scrapeMotionValues){const values={},motionValues=scrapeMotionValues(props);for(const key in motionValues)values[key]=resolveMotionValue(motionValues[key]);let{initial:initial,animate:animate}=props;const isControllingVariants$1=isControllingVariants(props),isVariantNode$1=isVariantNode(props);context&&isVariantNode$1&&!isControllingVariants$1&&!1!==props.inherit&&(void 0===initial&&(initial=context.initial),void 0===animate&&(animate=context.animate));let isInitialAnimationBlocked=!!presenceContext&&!1===presenceContext.initial;isInitialAnimationBlocked=isInitialAnimationBlocked||!1===initial;const variantToSet=isInitialAnimationBlocked?animate:initial;if(variantToSet&&"boolean"!=typeof variantToSet&&!isAnimationControls(variantToSet)){(Array.isArray(variantToSet)?variantToSet:[variantToSet]).forEach((definition=>{const resolved=resolveVariantFromProps(props,definition);if(!resolved)return;const{transitionEnd:transitionEnd,transition:transition,...target}=resolved;for(const key in target){let valueTarget=target[key];if(Array.isArray(valueTarget)){valueTarget=valueTarget[isInitialAnimationBlocked?valueTarget.length-1:0]}null!==valueTarget&&(values[key]=valueTarget)}for(const key in transitionEnd)values[key]=transitionEnd[key]}))}return values}const svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrape_motion_values_scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount:(props,instance,{renderState:renderState,latestValues:latestValues})=>{try{renderState.dimensions="function"==typeof instance.getBBox?instance.getBBox():instance.getBoundingClientRect()}catch(e){renderState.dimensions={x:0,y:0,width:0,height:0}}buildSVGAttrs(renderState,latestValues,{enableHardwareAcceleration:!1},props.transformTemplate),renderSVG(instance,renderState)}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps,createRenderState:createHtmlRenderState})};var AnimationType;function addDomEvent(target,eventName,handler,options={passive:!0}){return target.addEventListener(eventName,handler,options),()=>target.removeEventListener(eventName,handler)}function useDomEvent(ref,eventName,handler,options){(0,react.useEffect)((()=>{const element=ref.current;if(handler&&element)return addDomEvent(element,eventName,handler,options)}),[ref,eventName,handler,options])}function isMouseEvent(event){return"undefined"!=typeof PointerEvent&&event instanceof PointerEvent?!("mouse"!==event.pointerType):event instanceof MouseEvent}function isTouchEvent(event){return!!event.touches}!function(AnimationType){AnimationType.Animate="animate",AnimationType.Hover="whileHover",AnimationType.Tap="whileTap",AnimationType.Drag="whileDrag",AnimationType.Focus="whileFocus",AnimationType.InView="whileInView",AnimationType.Exit="exit"}(AnimationType||(AnimationType={}));const defaultPagePoint={pageX:0,pageY:0};function pointFromTouch(e,pointType="page"){const point=e.touches[0]||e.changedTouches[0]||defaultPagePoint;return{x:point[pointType+"X"],y:point[pointType+"Y"]}}function pointFromMouse(point,pointType="page"){return{x:point[pointType+"X"],y:point[pointType+"Y"]}}function extractEventInfo(event,pointType="page"){return{point:isTouchEvent(event)?pointFromTouch(event,pointType):pointFromMouse(event,pointType)}}const wrapHandler=(handler,shouldFilterPrimaryPointer=!1)=>{const listener=event=>handler(event,extractEventInfo(event));return shouldFilterPrimaryPointer?function filterPrimaryPointer(eventHandler){return event=>{const isMouseEvent=event instanceof MouseEvent;(!isMouseEvent||isMouseEvent&&0===event.button)&&eventHandler(event)}}(listener):listener},mouseEventNames={pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointercancel:"mousecancel",pointerover:"mouseover",pointerout:"mouseout",pointerenter:"mouseenter",pointerleave:"mouseleave"},touchEventNames={pointerdown:"touchstart",pointermove:"touchmove",pointerup:"touchend",pointercancel:"touchcancel"};function getPointerEventName(name){return is_browser.j&&null===window.onpointerdown?name:is_browser.j&&null===window.ontouchstart?touchEventNames[name]:is_browser.j&&null===window.onmousedown?mouseEventNames[name]:name}function addPointerEvent(target,eventName,handler,options){return addDomEvent(target,getPointerEventName(eventName),wrapHandler(handler,"pointerdown"===eventName),options)}function usePointerEvent(ref,eventName,handler,options){return useDomEvent(ref,getPointerEventName(eventName),handler&&wrapHandler(handler,"pointerdown"===eventName),options)}function createLock(name){let lock=null;return()=>{const openLock=()=>{lock=null};return null===lock&&(lock=name,openLock)}}const globalHorizontalLock=createLock("dragHorizontal"),globalVerticalLock=createLock("dragVertical");function getGlobalLock(drag){let lock=!1;if("y"===drag)lock=globalVerticalLock();else if("x"===drag)lock=globalHorizontalLock();else{const openHorizontal=globalHorizontalLock(),openVertical=globalVerticalLock();openHorizontal&&openVertical?lock=()=>{openHorizontal(),openVertical()}:(openHorizontal&&openHorizontal(),openVertical&&openVertical())}return lock}function isDragActive(){const openGestureLock=getGlobalLock(!0);return!openGestureLock||(openGestureLock(),!1)}function createHoverEvent(visualElement,isActive,callback){return(event,info)=>{isMouseEvent(event)&&!isDragActive()&&(visualElement.animationState&&visualElement.animationState.setActive(AnimationType.Hover,isActive),callback&&callback(event,info))}}const isNodeOrChild=(parent,child)=>!!child&&(parent===child||isNodeOrChild(parent,child.parentElement));var use_unmount_effect=__webpack_require__("./node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs");const combineFunctions=(a,b)=>v=>b(a(v)),pipe=(...transformers)=>transformers.reduce(combineFunctions);var process=__webpack_require__("./node_modules/framer-motion/dist/es/utils/process.mjs"),warn_once=__webpack_require__("./node_modules/framer-motion/dist/es/utils/warn-once.mjs");const observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry)},fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback)};function observeIntersection(element,options,callback){const rootInteresectionObserver=function initIntersectionObserver({root:root,...options}){const lookupRoot=root||document;observers.has(lookupRoot)||observers.set(lookupRoot,{});const rootObservers=observers.get(lookupRoot),key=JSON.stringify(options);return rootObservers[key]||(rootObservers[key]=new IntersectionObserver(fireAllObserverCallbacks,{root:root,...options})),rootObservers[key]}(options);return observerCallbacks.set(element,callback),rootInteresectionObserver.observe(element),()=>{observerCallbacks.delete(element),rootInteresectionObserver.unobserve(element)}}const thresholdNames={some:0,all:1};function useIntersectionObserver(shouldObserve,state,visualElement,{root:root,margin:rootMargin,amount:amount="some",once:once}){(0,react.useEffect)((()=>{if(!shouldObserve||!visualElement.current)return;const options={root:null==root?void 0:root.current,rootMargin:rootMargin,threshold:"number"==typeof amount?amount:thresholdNames[amount]};return observeIntersection(visualElement.current,options,(entry=>{const{isIntersecting:isIntersecting}=entry;if(state.isInView===isIntersecting)return;if(state.isInView=isIntersecting,once&&!isIntersecting&&state.hasEnteredView)return;isIntersecting&&(state.hasEnteredView=!0),visualElement.animationState&&visualElement.animationState.setActive(AnimationType.InView,isIntersecting);const props=visualElement.getProps(),callback=isIntersecting?props.onViewportEnter:props.onViewportLeave;callback&&callback(entry)}))}),[shouldObserve,root,rootMargin,amount])}function useMissingIntersectionObserver(shouldObserve,state,visualElement,{fallback:fallback=!0}){(0,react.useEffect)((()=>{shouldObserve&&fallback&&("production"!==process.O&&(0,warn_once.O)(!1,"IntersectionObserver not available on this device. whileInView animations will trigger on mount."),requestAnimationFrame((()=>{state.hasEnteredView=!0;const{onViewportEnter:onViewportEnter}=visualElement.getProps();onViewportEnter&&onViewportEnter(null),visualElement.animationState&&visualElement.animationState.setActive(AnimationType.InView,!0)})))}),[shouldObserve])}const makeRenderlessComponent=hook=>props=>(hook(props),null),gestureAnimations={inView:makeRenderlessComponent((function useViewport({visualElement:visualElement,whileInView:whileInView,onViewportEnter:onViewportEnter,onViewportLeave:onViewportLeave,viewport:viewport={}}){const state=(0,react.useRef)({hasEnteredView:!1,isInView:!1});let shouldObserve=Boolean(whileInView||onViewportEnter||onViewportLeave);viewport.once&&state.current.hasEnteredView&&(shouldObserve=!1),("undefined"==typeof IntersectionObserver?useMissingIntersectionObserver:useIntersectionObserver)(shouldObserve,state.current,visualElement,viewport)})),tap:makeRenderlessComponent((function useTapGesture({onTap:onTap,onTapStart:onTapStart,onTapCancel:onTapCancel,whileTap:whileTap,visualElement:visualElement}){const hasPressListeners=onTap||onTapStart||onTapCancel||whileTap,isPressing=(0,react.useRef)(!1),cancelPointerEndListeners=(0,react.useRef)(null),eventOptions={passive:!(onTapStart||onTap||onTapCancel||onPointerDown)};function removePointerEndListener(){cancelPointerEndListeners.current&&cancelPointerEndListeners.current(),cancelPointerEndListeners.current=null}function checkPointerEnd(){return removePointerEndListener(),isPressing.current=!1,visualElement.animationState&&visualElement.animationState.setActive(AnimationType.Tap,!1),!isDragActive()}function onPointerUp(event,info){checkPointerEnd()&&(isNodeOrChild(visualElement.current,event.target)?onTap&&onTap(event,info):onTapCancel&&onTapCancel(event,info))}function onPointerCancel(event,info){checkPointerEnd()&&onTapCancel&&onTapCancel(event,info)}function onPointerDown(event,info){removePointerEndListener(),isPressing.current||(isPressing.current=!0,cancelPointerEndListeners.current=pipe(addPointerEvent(window,"pointerup",onPointerUp,eventOptions),addPointerEvent(window,"pointercancel",onPointerCancel,eventOptions)),visualElement.animationState&&visualElement.animationState.setActive(AnimationType.Tap,!0),onTapStart&&onTapStart(event,info))}usePointerEvent(visualElement,"pointerdown",hasPressListeners?onPointerDown:void 0,eventOptions),(0,use_unmount_effect.z)(removePointerEndListener)})),focus:makeRenderlessComponent((function useFocusGesture({whileFocus:whileFocus,visualElement:visualElement}){const{animationState:animationState}=visualElement;useDomEvent(visualElement,"focus",whileFocus?()=>{animationState&&animationState.setActive(AnimationType.Focus,!0)}:void 0),useDomEvent(visualElement,"blur",whileFocus?()=>{animationState&&animationState.setActive(AnimationType.Focus,!1)}:void 0)})),hover:makeRenderlessComponent((function useHoverGesture({onHoverStart:onHoverStart,onHoverEnd:onHoverEnd,whileHover:whileHover,visualElement:visualElement}){usePointerEvent(visualElement,"pointerenter",onHoverStart||whileHover?createHoverEvent(visualElement,!0,onHoverStart):void 0,{passive:!onHoverStart}),usePointerEvent(visualElement,"pointerleave",onHoverEnd||whileHover?createHoverEvent(visualElement,!1,onHoverEnd):void 0,{passive:!onHoverEnd})}))};function usePresence(){const context=(0,react.useContext)(context_PresenceContext.O);if(null===context)return[!0,null];const{isPresent:isPresent,onExitComplete:onExitComplete,register:register}=context,id=(0,react.useId)();(0,react.useEffect)((()=>register(id)),[]);return!isPresent&&onExitComplete?[!1,()=>onExitComplete&&onExitComplete(id)]:[!0]}function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;const prevLength=prev.length;if(prevLength!==next.length)return!1;for(let i=0;i<prevLength;i++)if(prev[i]!==next[i])return!1;return!0}function __rest(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(null!=s&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]])}return t}Object.create;Object.create;const clamp_clamp=(min,max,v)=>Math.min(Math.max(v,min),max);function findSpring({duration:duration=800,bounce:bounce=.25,velocity:velocity=0,mass:mass=1}){let envelope,derivative,dampingRatio=1-bounce;dampingRatio=clamp_clamp(.05,1,dampingRatio),duration=clamp_clamp(.01,10,duration/1e3),dampingRatio<1?(envelope=undampedFreq=>{const exponentialDecay=undampedFreq*dampingRatio,delta=exponentialDecay*duration;return.001-(exponentialDecay-velocity)/calcAngularFreq(undampedFreq,dampingRatio)*Math.exp(-delta)},derivative=undampedFreq=>{const delta=undampedFreq*dampingRatio*duration,d=delta*velocity+velocity,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration,f=Math.exp(-delta),g=calcAngularFreq(Math.pow(undampedFreq,2),dampingRatio);return(.001-envelope(undampedFreq)>0?-1:1)*((d-e)*f)/g}):(envelope=undampedFreq=>Math.exp(-undampedFreq*duration)*((undampedFreq-velocity)*duration+1)-.001,derivative=undampedFreq=>Math.exp(-undampedFreq*duration)*(duration*duration*(velocity-undampedFreq)));const undampedFreq=function approximateRoot(envelope,derivative,initialGuess){let result=initialGuess;for(let i=1;i<12;i++)result-=envelope(result)/derivative(result);return result}(envelope,derivative,5/duration);if(duration*=1e3,isNaN(undampedFreq))return{stiffness:100,damping:10,duration:duration};{const stiffness=Math.pow(undampedFreq,2)*mass;return{stiffness:stiffness,damping:2*dampingRatio*Math.sqrt(mass*stiffness),duration:duration}}}function calcAngularFreq(undampedFreq,dampingRatio){return undampedFreq*Math.sqrt(1-dampingRatio*dampingRatio)}const durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];function isSpringType(options,keys){return keys.some((key=>void 0!==options[key]))}function spring(_a){var{from:from=0,to:to=1,restSpeed:restSpeed=2,restDelta:restDelta}=_a,options=__rest(_a,["from","to","restSpeed","restDelta"]);const state={done:!1,value:from};let{stiffness:stiffness,damping:damping,mass:mass,velocity:velocity,duration:duration,isResolvedFromDuration:isResolvedFromDuration}=function getSpringOptions(options){let springOptions=Object.assign({velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1},options);if(!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)){const derived=findSpring(options);springOptions=Object.assign(Object.assign(Object.assign({},springOptions),derived),{velocity:0,mass:1}),springOptions.isResolvedFromDuration=!0}return springOptions}(options),resolveSpring=zero,resolveVelocity=zero;function createSpring(){const initialVelocity=velocity?-velocity/1e3:0,initialDelta=to-from,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),undampedAngularFreq=Math.sqrt(stiffness/mass)/1e3;if(void 0===restDelta&&(restDelta=Math.min(Math.abs(to-from)/100,.4)),dampingRatio<1){const angularFreq=calcAngularFreq(undampedAngularFreq,dampingRatio);resolveSpring=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return to-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t))},resolveVelocity=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return dampingRatio*undampedAngularFreq*envelope*(Math.sin(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq+initialDelta*Math.cos(angularFreq*t))-envelope*(Math.cos(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)-angularFreq*initialDelta*Math.sin(angularFreq*t))}}else if(1===dampingRatio)resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t),freqForT=Math.min(dampedAngularFreq*t,300);return to-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}}return createSpring(),{next:t=>{const current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{const currentVelocity=1e3*resolveVelocity(t),isBelowVelocityThreshold=Math.abs(currentVelocity)<=restSpeed,isBelowDisplacementThreshold=Math.abs(to-current)<=restDelta;state.done=isBelowVelocityThreshold&&isBelowDisplacementThreshold}return state.value=state.done?to:current,state},flipTarget:()=>{velocity=-velocity,[from,to]=[to,from],createSpring()}}}spring.needsInterpolation=(a,b)=>"string"==typeof a||"string"==typeof b;const zero=_t=>0,progress=(from,to,value)=>{const toFromDifference=to-from;return 0===toFromDifference?1:(value-from)/toFromDifference},mix=(from,to,progress)=>-progress*from+progress*to+from,isColorString=(type,testProp)=>v=>Boolean(isString(v)&&singleColorRegex.test(v)&&v.startsWith(type)||testProp&&Object.prototype.hasOwnProperty.call(v,testProp)),splitColor=(aName,bName,cName)=>v=>{if(!isString(v))return v;const[a,b,c,alpha]=v.match(floatRegex);return{[aName]:parseFloat(a),[bName]:parseFloat(b),[cName]:parseFloat(c),alpha:void 0!==alpha?parseFloat(alpha):1}},clampRgbUnit=clamp(0,255),rgbUnit=Object.assign(Object.assign({},number),{transform:v=>Math.round(clampRgbUnit(v))}),rgba={test:isColorString("rgb","red"),parse:splitColor("red","green","blue"),transform:({red:red,green:green,blue:blue,alpha:alpha$1=1})=>"rgba("+rgbUnit.transform(red)+", "+rgbUnit.transform(green)+", "+rgbUnit.transform(blue)+", "+sanitize(alpha.transform(alpha$1))+")"};const hex={test:isColorString("#"),parse:function parseHex(v){let r="",g="",b="",a="";return v.length>5?(r=v.substr(1,2),g=v.substr(3,2),b=v.substr(5,2),a=v.substr(7,2)):(r=v.substr(1,1),g=v.substr(2,1),b=v.substr(3,1),a=v.substr(4,1),r+=r,g+=g,b+=b,a+=a),{red:parseInt(r,16),green:parseInt(g,16),blue:parseInt(b,16),alpha:a?parseInt(a,16)/255:1}},transform:rgba.transform},hsla={test:isColorString("hsl","hue"),parse:splitColor("hue","saturation","lightness"),transform:({hue:hue,saturation:saturation,lightness:lightness,alpha:alpha$1=1})=>"hsla("+Math.round(hue)+", "+percent.transform(sanitize(saturation))+", "+percent.transform(sanitize(lightness))+", "+sanitize(alpha.transform(alpha$1))+")"};function hueToRgb(p,q,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslaToRgba({hue:hue,saturation:saturation,lightness:lightness,alpha:alpha}){hue/=360,lightness/=100;let red=0,green=0,blue=0;if(saturation/=100){const q=lightness<.5?lightness*(1+saturation):lightness+saturation-lightness*saturation,p=2*lightness-q;red=hueToRgb(p,q,hue+1/3),green=hueToRgb(p,q,hue),blue=hueToRgb(p,q,hue-1/3)}else red=green=blue=lightness;return{red:Math.round(255*red),green:Math.round(255*green),blue:Math.round(255*blue),alpha:alpha}}const mixLinearColor=(from,to,v)=>{const fromExpo=from*from,toExpo=to*to;return Math.sqrt(Math.max(0,v*(toExpo-fromExpo)+fromExpo))},colorTypes=[hex,rgba,hsla],getColorType=v=>colorTypes.find((type=>type.test(v))),notAnimatable=color=>`'${color}' is not an animatable color. Use the equivalent color code instead.`,mixColor=(from,to)=>{let fromColorType=getColorType(from),toColorType=getColorType(to);notAnimatable(from),notAnimatable(to);let fromColor=fromColorType.parse(from),toColor=toColorType.parse(to);fromColorType===hsla&&(fromColor=hslaToRgba(fromColor),fromColorType=rgba),toColorType===hsla&&(toColor=hslaToRgba(toColor),toColorType=rgba);const blended=Object.assign({},fromColor);return v=>{for(const key in blended)"alpha"!==key&&(blended[key]=mixLinearColor(fromColor[key],toColor[key],v));return blended.alpha=mix(fromColor.alpha,toColor.alpha,v),fromColorType.transform(blended)}},color={test:v=>rgba.test(v)||hex.test(v)||hsla.test(v),parse:v=>rgba.test(v)?rgba.parse(v):hsla.test(v)?hsla.parse(v):hex.parse(v),transform:v=>isString(v)?v:v.hasOwnProperty("red")?rgba.transform(v):hsla.transform(v)};function analyse(v){"number"==typeof v&&(v=`${v}`);const values=[];let numColors=0;const colors=v.match(colorRegex);colors&&(numColors=colors.length,v=v.replace(colorRegex,"${c}"),values.push(...colors.map(color.parse)));const numbers=v.match(floatRegex);return numbers&&(v=v.replace(floatRegex,"${n}"),values.push(...numbers.map(number.parse))),{values:values,numColors:numColors,tokenised:v}}function parse(v){return analyse(v).values}function createTransformer(v){const{values:values,numColors:numColors,tokenised:tokenised}=analyse(v),numValues=values.length;return v=>{let output=tokenised;for(let i=0;i<numValues;i++)output=output.replace(i<numColors?"${c}":"${n}",i<numColors?color.transform(v[i]):sanitize(v[i]));return output}}const convertNumbersToZero=v=>"number"==typeof v?0:v;const complex={test:function test(v){var _a,_b,_c,_d;return isNaN(v)&&isString(v)&&(null!==(_b=null===(_a=v.match(floatRegex))||void 0===_a?void 0:_a.length)&&void 0!==_b?_b:0)+(null!==(_d=null===(_c=v.match(colorRegex))||void 0===_c?void 0:_c.length)&&void 0!==_d?_d:0)>0},parse:parse,createTransformer:createTransformer,getAnimatableNone:function getAnimatableNone(v){const parsed=parse(v);return createTransformer(v)(parsed.map(convertNumbersToZero))}},isNum=v=>"number"==typeof v;function getMixer(origin,target){return isNum(origin)?v=>mix(origin,target,v):color.test(origin)?mixColor(origin,target):mixComplex(origin,target)}const mixArray=(from,to)=>{const output=[...from],numValues=output.length,blendValue=from.map(((fromThis,i)=>getMixer(fromThis,to[i])));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{const output=Object.assign(Object.assign({},origin),target),blendValue={};for(const key in output)void 0!==origin[key]&&void 0!==target[key]&&(blendValue[key]=getMixer(origin[key],target[key]));return v=>{for(const key in blendValue)output[key]=blendValue[key](v);return output}};function mix_complex_analyse(value){const parsed=complex.parse(value),numValues=parsed.length;let numNumbers=0,numRGB=0,numHSL=0;for(let i=0;i<numValues;i++)numNumbers||"number"==typeof parsed[i]?numNumbers++:void 0!==parsed[i].hue?numHSL++:numRGB++;return{parsed:parsed,numNumbers:numNumbers,numRGB:numRGB,numHSL:numHSL}}const mixComplex=(origin,target)=>{const template=complex.createTransformer(target),originStats=mix_complex_analyse(origin),targetStats=mix_complex_analyse(target);return originStats.numHSL===targetStats.numHSL&&originStats.numRGB===targetStats.numRGB&&originStats.numNumbers>=targetStats.numNumbers?pipe(mixArray(originStats.parsed,targetStats.parsed),template):p=>`${p>0?target:origin}`},mixNumber=(from,to)=>p=>mix(from,to,p);function createMixers(output,ease,customMixer){const mixers=[],mixerFactory=customMixer||function detectMixerFactory(v){return"number"==typeof v?mixNumber:"string"==typeof v?color.test(v)?mixColor:mixComplex:Array.isArray(v)?mixArray:"object"==typeof v?mixObject:void 0}(output[0]),numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=mixerFactory(output[i],output[i+1]);if(ease){const easingFunction=Array.isArray(ease)?ease[i]:ease;mixer=pipe(easingFunction,mixer)}mixers.push(mixer)}return mixers}function interpolate(input,output,{clamp:isClamp=!0,ease:ease,mixer:mixer}={}){const inputLength=input.length;output.length,!ease||!Array.isArray(ease)||ease.length,input[0]>input[inputLength-1]&&(input=[].concat(input),output=[].concat(output),input.reverse(),output.reverse());const mixers=createMixers(output,ease,mixer),interpolator=2===inputLength?function fastInterpolate([from,to],[mixer]){return v=>mixer(progress(from,to,v))}(input,mixers):function slowInterpolate(input,mixers){const inputLength=input.length,lastInputIndex=inputLength-1;return v=>{let mixerIndex=0,foundMixerIndex=!1;if(v<=input[0]?foundMixerIndex=!0:v>=input[lastInputIndex]&&(mixerIndex=lastInputIndex-1,foundMixerIndex=!0),!foundMixerIndex){let i=1;for(;i<inputLength&&!(input[i]>v||i===lastInputIndex);i++);mixerIndex=i-1}const progressInRange=progress(input[mixerIndex],input[mixerIndex+1],v);return mixers[mixerIndex](progressInRange)}}(input,mixers);return isClamp?v=>interpolator(clamp_clamp(input[0],input[inputLength-1],v)):interpolator}const reverseEasing=easing=>p=>1-easing(1-p),mirrorEasing=easing=>p=>p<=.5?easing(2*p)/2:(2-easing(2*(1-p)))/2,createBackIn=power=>p=>p*p*((power+1)*p-power),linear=p=>p,easeIn=(power=2,p=>Math.pow(p,power));var power;const easeOut=reverseEasing(easeIn),easeInOut=mirrorEasing(easeIn),circIn=p=>1-Math.sin(Math.acos(p)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circOut),backIn=createBackIn(1.525),backOut=reverseEasing(backIn),backInOut=mirrorEasing(backIn),anticipate=(power=>{const backEasing=createBackIn(power);return p=>(p*=2)<1?.5*backEasing(p):.5*(2-Math.pow(2,-10*(p-1)))})(1.525),bounceOut=p=>{if(1===p||0===p)return p;const p2=p*p;return p<.36363636363636365?7.5625*p2:p<.7272727272727273?9.075*p2-9.9*p+3.4:p<.9?12.066481994459833*p2-19.63545706371191*p+8.898060941828255:10.8*p*p-20.52*p+10.72},bounceIn=reverseEasing(bounceOut);function defaultEasing(values,easing){return values.map((()=>easing||easeInOut)).splice(0,values.length-1)}function keyframes({from:from=0,to:to=1,ease:ease,offset:offset,duration:duration=300}){const state={done:!1,value:from},values=Array.isArray(to)?to:[from,to],times=function convertOffsetToTimes(offset,duration){return offset.map((o=>o*duration))}(offset&&offset.length===values.length?offset:function defaultOffset(values){const numValues=values.length;return values.map(((_value,i)=>0!==i?i/(numValues-1):0))}(values),duration);function createInterpolator(){return interpolate(times,values,{ease:Array.isArray(ease)?ease:defaultEasing(values,ease)})}let interpolator=createInterpolator();return{next:t=>(state.value=interpolator(t),state.done=t>=duration,state),flipTarget:()=>{values.reverse(),interpolator=createInterpolator()}}}const types={keyframes:keyframes,spring:spring,decay:function decay({velocity:velocity=0,from:from=0,power:power=.8,timeConstant:timeConstant=350,restDelta:restDelta=.5,modifyTarget:modifyTarget}){const state={done:!1,value:from};let amplitude=power*velocity;const ideal=from+amplitude,target=void 0===modifyTarget?ideal:modifyTarget(ideal);return target!==ideal&&(amplitude=target-from),{next:t=>{const delta=-amplitude*Math.exp(-t/timeConstant);return state.done=!(delta>restDelta||delta<-restDelta),state.value=state.done?target:target+delta,state},flipTarget:()=>{}}}};var es=__webpack_require__("./node_modules/framesync/dist/es/index.mjs");function loopElapsed(elapsed,duration,delay=0){return elapsed-duration-delay}const framesync=update=>{const passTimestamp=({delta:delta})=>update(delta);return{start:()=>es.ZP.update(passTimestamp,!0),stop:()=>es.qY.update(passTimestamp)}};function animate(_a){var _b,_c,{from:from,autoplay:autoplay=!0,driver:driver=framesync,elapsed:elapsed=0,repeat:repeatMax=0,repeatType:repeatType="loop",repeatDelay:repeatDelay=0,onPlay:onPlay,onStop:onStop,onComplete:onComplete,onRepeat:onRepeat,onUpdate:onUpdate}=_a,options=__rest(_a,["from","autoplay","driver","elapsed","repeat","repeatType","repeatDelay","onPlay","onStop","onComplete","onRepeat","onUpdate"]);let driverControls,latest,interpolateFromNumber,{to:to}=options,repeatCount=0,computedDuration=options.duration,isComplete=!1,isForwardPlayback=!0;const animator=function detectAnimationFromOptions(config){if(Array.isArray(config.to))return keyframes;if(types[config.type])return types[config.type];const keys=new Set(Object.keys(config));return keys.has("ease")||keys.has("duration")&&!keys.has("dampingRatio")?keyframes:keys.has("dampingRatio")||keys.has("stiffness")||keys.has("mass")||keys.has("damping")||keys.has("restSpeed")||keys.has("restDelta")?spring:keyframes}(options);(null===(_c=(_b=animator).needsInterpolation)||void 0===_c?void 0:_c.call(_b,from,to))&&(interpolateFromNumber=interpolate([0,100],[from,to],{clamp:!1}),from=0,to=100);const animation=animator(Object.assign(Object.assign({},options),{from:from,to:to}));function repeat(){repeatCount++,"reverse"===repeatType?(isForwardPlayback=repeatCount%2==0,elapsed=function reverseElapsed(elapsed,duration,delay=0,isForwardPlayback=!0){return isForwardPlayback?loopElapsed(duration+-elapsed,duration,delay):duration-(elapsed-duration)+delay}(elapsed,computedDuration,repeatDelay,isForwardPlayback)):(elapsed=loopElapsed(elapsed,computedDuration,repeatDelay),"mirror"===repeatType&&animation.flipTarget()),isComplete=!1,onRepeat&&onRepeat()}function update(delta){if(isForwardPlayback||(delta=-delta),elapsed+=delta,!isComplete){const state=animation.next(Math.max(0,elapsed));latest=state.value,interpolateFromNumber&&(latest=interpolateFromNumber(latest)),isComplete=isForwardPlayback?state.done:elapsed<=0}null==onUpdate||onUpdate(latest),isComplete&&(0===repeatCount&&(null!=computedDuration||(computedDuration=elapsed)),repeatCount<repeatMax?function hasRepeatDelayElapsed(elapsed,duration,delay,isForwardPlayback){return isForwardPlayback?elapsed>=duration+delay:elapsed<=-delay}(elapsed,computedDuration,repeatDelay,isForwardPlayback)&&repeat():function complete(){driverControls.stop(),onComplete&&onComplete()}())}return autoplay&&function play(){null==onPlay||onPlay(),driverControls=driver(update),driverControls.start()}(),{stop:()=>{null==onStop||onStop(),driverControls.stop()}}}function velocityPerSecond(velocity,frameDuration){return frameDuration?velocity*(1e3/frameDuration):0}const secondsToMilliseconds=seconds=>1e3*seconds,a=(a1,a2)=>1-3*a2+3*a1,b=(a1,a2)=>3*a2-6*a1,c=a1=>3*a1,calcBezier=(t,a1,a2)=>((a(a1,a2)*t+b(a1,a2))*t+c(a1))*t,getSlope=(t,a1,a2)=>3*a(a1,a2)*t*t+2*b(a1,a2)*t+c(a1);function cubicBezier(mX1,mY1,mX2,mY2){if(mX1===mY1&&mX2===mY2)return linear;const sampleValues=new Float32Array(11);for(let i=0;i<11;++i)sampleValues[i]=calcBezier(.1*i,mX1,mX2);function getTForX(aX){let intervalStart=0,currentSample=1;for(;10!==currentSample&&sampleValues[currentSample]<=aX;++currentSample)intervalStart+=.1;--currentSample;const guessForT=intervalStart+.1*((aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample])),initialSlope=getSlope(guessForT,mX1,mX2);return initialSlope>=.001?function newtonRaphsonIterate(aX,aGuessT,mX1,mX2){for(let i=0;i<8;++i){const currentSlope=getSlope(aGuessT,mX1,mX2);if(0===currentSlope)return aGuessT;aGuessT-=(calcBezier(aGuessT,mX1,mX2)-aX)/currentSlope}return aGuessT}(aX,guessForT,mX1,mX2):0===initialSlope?guessForT:function binarySubdivide(aX,aA,aB,mX1,mX2){let currentX,currentT,i=0;do{currentT=aA+(aB-aA)/2,currentX=calcBezier(currentT,mX1,mX2)-aX,currentX>0?aB=currentT:aA=currentT}while(Math.abs(currentX)>1e-7&&++i<10);return currentT}(aX,intervalStart,intervalStart+.1,mX1,mX2)}return t=>0===t||1===t?t:calcBezier(getTForX(t),mY1,mY2)}const easingLookup={linear:linear,easeIn:easeIn,easeInOut:easeInOut,easeOut:easeOut,circIn:circIn,circInOut:circInOut,circOut:circOut,backIn:backIn,backInOut:backInOut,backOut:backOut,anticipate:anticipate,bounceIn:bounceIn,bounceInOut:p=>p<.5?.5*(1-bounceOut(1-2*p)):.5*bounceOut(2*p-1)+.5,bounceOut:bounceOut},easingDefinitionToFunction=definition=>{if(Array.isArray(definition)){definition.length;const[x1,y1,x2,y2]=definition;return cubicBezier(x1,y1,x2,y2)}return"string"==typeof definition?easingLookup[definition]:definition},isAnimatable=(key,value)=>"zIndex"!==key&&(!("number"!=typeof value&&!Array.isArray(value))||!("string"!=typeof value||!complex.test(value)||value.startsWith("url("))),underDampedSpring=()=>({type:"spring",stiffness:500,damping:25,restSpeed:10}),criticallyDampedSpring=to=>({type:"spring",stiffness:550,damping:0===to?2*Math.sqrt(550):30,restSpeed:10}),linearTween=()=>({type:"keyframes",ease:"linear",duration:.3}),default_transitions_keyframes=values=>({type:"keyframes",duration:.8,values:values}),defaultTransitions={x:underDampedSpring,y:underDampedSpring,z:underDampedSpring,rotate:underDampedSpring,rotateX:underDampedSpring,rotateY:underDampedSpring,rotateZ:underDampedSpring,scaleX:criticallyDampedSpring,scaleY:criticallyDampedSpring,scale:criticallyDampedSpring,opacity:linearTween,backgroundColor:linearTween,color:linearTween,default:criticallyDampedSpring},getDefaultTransition=(valueKey,to)=>{let transitionFactory;return transitionFactory=isKeyframesTarget(to)?default_transitions_keyframes:defaultTransitions[valueKey]||defaultTransitions.default,{to:to,...transitionFactory(to)}},maxDefaults=new Set(["brightness","contrast","saturate","opacity"]);function applyDefaultFilter(v){let[name,value]=v.slice(0,-1).split("(");if("drop-shadow"===name)return v;const[number]=value.match(floatRegex)||[];if(!number)return v;const unit=value.replace(number,"");let defaultValue=maxDefaults.has(name)?1:0;return number!==value&&(defaultValue*=100),name+"("+defaultValue+unit+")"}const functionRegex=/([a-z-]*)\(.*?\)/g,filter=Object.assign(Object.assign({},complex),{getAnimatableNone:v=>{const functions=v.match(functionRegex);return functions?functions.map(applyDefaultFilter).join(" "):v}}),defaultValueTypes={...numberValueTypes,color:color,backgroundColor:color,outlineColor:color,fill:color,stroke:color,borderColor:color,borderTopColor:color,borderRightColor:color,borderBottomColor:color,borderLeftColor:color,filter:filter,WebkitFilter:filter},getDefaultValueType=key=>defaultValueTypes[key];function animatable_none_getAnimatableNone(key,value){var _a;let defaultValueType=getDefaultValueType(key);return defaultValueType!==filter&&(defaultValueType=complex),null===(_a=defaultValueType.getAnimatableNone)||void 0===_a?void 0:_a.call(defaultValueType,value)}const instantAnimationState_current=!1;function delay(callback,timeout){const start=performance.now(),checkElapsed=({timestamp:timestamp})=>{const elapsed=timestamp-start;elapsed>=timeout&&(es.qY.read(checkElapsed),callback(elapsed-timeout))};return es.ZP.read(checkElapsed,!0),()=>es.qY.read(checkElapsed)}let legacyRepeatWarning=!1;function convertTransitionToAnimationOptions({ease:ease,times:times,yoyo:yoyo,flip:flip,loop:loop,...transition}){const options={...transition};return times&&(options.offset=times),transition.duration&&(options.duration=secondsToMilliseconds(transition.duration)),transition.repeatDelay&&(options.repeatDelay=secondsToMilliseconds(transition.repeatDelay)),ease&&(options.ease=(ease=>Array.isArray(ease)&&"number"!=typeof ease[0])(ease)?ease.map(easingDefinitionToFunction):easingDefinitionToFunction(ease)),"tween"===transition.type&&(options.type="keyframes"),(yoyo||loop||flip)&&(legacyRepeatWarning=!0,yoyo?options.repeatType="reverse":loop?options.repeatType="loop":flip&&(options.repeatType="mirror"),options.repeat=loop||yoyo||flip||transition.repeat),"spring"!==transition.type&&(options.type="keyframes"),options}function getPopmotionAnimationOptions(transition,options,key){return Array.isArray(options.to)&&void 0===transition.duration&&(transition.duration=.8),function hydrateKeyframes(options){return Array.isArray(options.to)&&null===options.to[0]&&(options.to=[...options.to],options.to[0]=options.from),options}(options),function isTransitionDefined({when:when,delay:_delay,delayChildren:delayChildren,staggerChildren:staggerChildren,staggerDirection:staggerDirection,repeat:repeat,repeatType:repeatType,repeatDelay:repeatDelay,from:from,...transition}){return!!Object.keys(transition).length}(transition)||(transition={...transition,...getDefaultTransition(key,options.to)}),{...options,...convertTransitionToAnimationOptions(transition)}}function getAnimation(key,value,target,transition,onComplete){const valueTransition=getValueTransition(transition,key)||{};let origin=void 0!==valueTransition.from?valueTransition.from:value.get();const isTargetAnimatable=isAnimatable(key,target);"none"===origin&&isTargetAnimatable&&"string"==typeof target?origin=animatable_none_getAnimatableNone(key,target):isZero(origin)&&"string"==typeof target?origin=getZeroUnit(target):!Array.isArray(target)&&isZero(target)&&"string"==typeof origin&&(target=getZeroUnit(origin));const isOriginAnimatable=isAnimatable(key,origin);return isOriginAnimatable&&isTargetAnimatable&&!1!==valueTransition.type?function start(){const options={from:origin,to:target,velocity:value.getVelocity(),onComplete:onComplete,onUpdate:v=>value.set(v)};return"inertia"===valueTransition.type||"decay"===valueTransition.type?function inertia({from:from=0,velocity:velocity=0,min:min,max:max,power:power=.8,timeConstant:timeConstant=750,bounceStiffness:bounceStiffness=500,bounceDamping:bounceDamping=10,restDelta:restDelta=1,modifyTarget:modifyTarget,driver:driver,onUpdate:onUpdate,onComplete:onComplete,onStop:onStop}){let currentAnimation;function isOutOfBounds(v){return void 0!==min&&v<min||void 0!==max&&v>max}function boundaryNearest(v){return void 0===min?max:void 0===max||Math.abs(min-v)<Math.abs(max-v)?min:max}function startAnimation(options){null==currentAnimation||currentAnimation.stop(),currentAnimation=animate(Object.assign(Object.assign({},options),{driver:driver,onUpdate:v=>{var _a;null==onUpdate||onUpdate(v),null===(_a=options.onUpdate)||void 0===_a||_a.call(options,v)},onComplete:onComplete,onStop:onStop}))}function startSpring(options){startAnimation(Object.assign({type:"spring",stiffness:bounceStiffness,damping:bounceDamping,restDelta:restDelta},options))}if(isOutOfBounds(from))startSpring({from:from,velocity:velocity,to:boundaryNearest(from)});else{let target=power*velocity+from;void 0!==modifyTarget&&(target=modifyTarget(target));const boundary=boundaryNearest(target),heading=boundary===min?-1:1;let prev,current;const checkBoundary=v=>{prev=current,current=v,velocity=velocityPerSecond(v-prev,(0,es.$B)().delta),(1===heading&&v>boundary||-1===heading&&v<boundary)&&startSpring({from:v,to:boundary,velocity:velocity})};startAnimation({type:"decay",from:from,velocity:velocity,timeConstant:timeConstant,power:power,restDelta:restDelta,modifyTarget:modifyTarget,onUpdate:isOutOfBounds(target)?checkBoundary:void 0})}return{stop:()=>null==currentAnimation?void 0:currentAnimation.stop()}}({...options,...valueTransition}):animate({...getPopmotionAnimationOptions(valueTransition,options,key),onUpdate:v=>{options.onUpdate(v),valueTransition.onUpdate&&valueTransition.onUpdate(v)},onComplete:()=>{options.onComplete(),valueTransition.onComplete&&valueTransition.onComplete()}})}:function set(){const finalTarget=resolveFinalValueInKeyframes(target);return value.set(finalTarget),onComplete(),valueTransition.onUpdate&&valueTransition.onUpdate(finalTarget),valueTransition.onComplete&&valueTransition.onComplete(),{stop:()=>{}}}}function isZero(value){return 0===value||"string"==typeof value&&0===parseFloat(value)&&-1===value.indexOf(" ")}function getZeroUnit(potentialUnitType){return"number"==typeof potentialUnitType?0:animatable_none_getAnimatableNone("",potentialUnitType)}function getValueTransition(transition,key){return transition[key]||transition.default||transition}function startAnimation(key,value,target,transition={}){return instantAnimationState_current&&(transition={type:!1}),value.start((onComplete=>{let controls;const animation=getAnimation(key,value,target,transition,onComplete),delayBy=function getDelayFromTransition(transition,key){var _a,_b;return null!==(_b=null!==(_a=(getValueTransition(transition,key)||{}).delay)&&void 0!==_a?_a:transition.delay)&&void 0!==_b?_b:0}(transition,key),start=()=>controls=animation();let cancelDelay;return delayBy?cancelDelay=delay(start,secondsToMilliseconds(delayBy)):start(),()=>{cancelDelay&&cancelDelay(),controls&&controls.stop()}}))}const isZeroValueString=v=>/^0[^.\s]+$/.test(v);function addUniqueItem(arr,item){-1===arr.indexOf(item)&&arr.push(item)}function removeItem(arr,item){const index=arr.indexOf(item);index>-1&&arr.splice(index,1)}class SubscriptionManager{constructor(){this.subscriptions=[]}add(handler){return addUniqueItem(this.subscriptions,handler),()=>removeItem(this.subscriptions,handler)}notify(a,b,c){const numSubscriptions=this.subscriptions.length;if(numSubscriptions)if(1===numSubscriptions)this.subscriptions[0](a,b,c);else for(let i=0;i<numSubscriptions;i++){const handler=this.subscriptions[i];handler&&handler(a,b,c)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}class MotionValue{constructor(init){var value;this.version="7.6.15",this.timeDelta=0,this.lastUpdated=0,this.updateSubscribers=new SubscriptionManager,this.velocityUpdateSubscribers=new SubscriptionManager,this.renderSubscribers=new SubscriptionManager,this.canTrackVelocity=!1,this.updateAndNotify=(v,render=!0)=>{this.prev=this.current,this.current=v;const{delta:delta,timestamp:timestamp}=(0,es.$B)();this.lastUpdated!==timestamp&&(this.timeDelta=delta,this.lastUpdated=timestamp,es.ZP.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&&this.updateSubscribers.notify(this.current),this.velocityUpdateSubscribers.getSize()&&this.velocityUpdateSubscribers.notify(this.getVelocity()),render&&this.renderSubscribers.notify(this.current)},this.scheduleVelocityCheck=()=>es.ZP.postRender(this.velocityCheck),this.velocityCheck=({timestamp:timestamp})=>{timestamp!==this.lastUpdated&&(this.prev=this.current,this.velocityUpdateSubscribers.notify(this.getVelocity()))},this.hasAnimated=!1,this.prev=this.current=init,this.canTrackVelocity=(value=this.current,!isNaN(parseFloat(value)))}onChange(subscription){return this.updateSubscribers.add(subscription)}clearListeners(){this.updateSubscribers.clear()}onRenderRequest(subscription){return subscription(this.get()),this.renderSubscribers.add(subscription)}attach(passiveEffect){this.passiveEffect=passiveEffect}set(v,render=!0){render&&this.passiveEffect?this.passiveEffect(v,this.updateAndNotify):this.updateAndNotify(v,render)}get(){return this.current}getPrevious(){return this.prev}getVelocity(){return this.canTrackVelocity?velocityPerSecond(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0}start(animation){return this.stop(),new Promise((resolve=>{this.hasAnimated=!0,this.stopAnimation=animation(resolve)})).then((()=>this.clearAnimation()))}stop(){this.stopAnimation&&this.stopAnimation(),this.clearAnimation()}isAnimating(){return!!this.stopAnimation}clearAnimation(){this.stopAnimation=null}destroy(){this.updateSubscribers.clear(),this.renderSubscribers.clear(),this.stop()}}function motionValue(init){return new MotionValue(init)}const testValueType=v=>type=>type.test(v),dimensionValueTypes=[number,px,percent,degrees,vw,vh,{test:v=>"auto"===v,parse:v=>v}],findDimensionValueType=v=>dimensionValueTypes.find(testValueType(v)),valueTypes=[...dimensionValueTypes,color,complex],findValueType=v=>valueTypes.find(testValueType(v));function resolveVariant(visualElement,definition,custom){const props=visualElement.getProps();return resolveVariantFromProps(props,definition,void 0!==custom?custom:props.custom,function getCurrent(visualElement){const current={};return visualElement.values.forEach(((value,key)=>current[key]=value.get())),current}(visualElement),function getVelocity(visualElement){const velocity={};return visualElement.values.forEach(((value,key)=>velocity[key]=value.getVelocity())),velocity}(visualElement))}function setMotionValue(visualElement,key,value){visualElement.hasValue(key)?visualElement.getValue(key).set(value):visualElement.addValue(key,motionValue(value))}function setTarget(visualElement,definition){const resolved=resolveVariant(visualElement,definition);let{transitionEnd:transitionEnd={},transition:transition={},...target}=resolved?visualElement.makeTargetAnimatable(resolved,!1):{};target={...target,...transitionEnd};for(const key in target){setMotionValue(visualElement,key,resolveFinalValueInKeyframes(target[key]))}}function getOriginFromTransition(key,transition){if(!transition)return;return(transition[key]||transition.default||transition).from}function isWillChangeMotionValue(value){return Boolean(isMotionValue(value)&&value.add)}function animateVariant(visualElement,variant,options={}){var _a;const resolved=resolveVariant(visualElement,variant,options.custom);let{transition:transition=visualElement.getDefaultTransition()||{}}=resolved||{};options.transitionOverride&&(transition=options.transitionOverride);const getAnimation=resolved?()=>animateTarget(visualElement,resolved,options):()=>Promise.resolve(),getChildAnimations=(null===(_a=visualElement.variantChildren)||void 0===_a?void 0:_a.size)?(forwardDelay=0)=>{const{delayChildren:delayChildren=0,staggerChildren:staggerChildren,staggerDirection:staggerDirection}=transition;return function animateChildren(visualElement,variant,delayChildren=0,staggerChildren=0,staggerDirection=1,options){const animations=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=1===staggerDirection?(i=0)=>i*staggerChildren:(i=0)=>maxStaggerDuration-i*staggerChildren;return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(((child,i)=>{animations.push(animateVariant(child,variant,{...options,delay:delayChildren+generateStaggerDuration(i)}).then((()=>child.notify("AnimationComplete",variant))))})),Promise.all(animations)}(visualElement,variant,delayChildren+forwardDelay,staggerChildren,staggerDirection,options)}:()=>Promise.resolve(),{when:when}=transition;if(when){const[first,last]="beforeChildren"===when?[getAnimation,getChildAnimations]:[getChildAnimations,getAnimation];return first().then(last)}return Promise.all([getAnimation(),getChildAnimations(options.delay)])}function animateTarget(visualElement,definition,{delay:delay=0,transitionOverride:transitionOverride,type:type}={}){var _a;let{transition:transition=visualElement.getDefaultTransition(),transitionEnd:transitionEnd,...target}=visualElement.makeTargetAnimatable(definition);const willChange=visualElement.getValue("willChange");transitionOverride&&(transition=transitionOverride);const animations=[],animationTypeState=type&&(null===(_a=visualElement.animationState)||void 0===_a?void 0:_a.getState()[type]);for(const key in target){const value=visualElement.getValue(key),valueTarget=target[key];if(!value||void 0===valueTarget||animationTypeState&&shouldBlockAnimation(animationTypeState,key))continue;let valueTransition={delay:delay,...transition};visualElement.shouldReduceMotion&&transformProps.has(key)&&(valueTransition={...valueTransition,type:!1,delay:0});let animation=startAnimation(key,value,valueTarget,valueTransition);isWillChangeMotionValue(willChange)&&(willChange.add(key),animation=animation.then((()=>willChange.remove(key)))),animations.push(animation)}return Promise.all(animations).then((()=>{transitionEnd&&setTarget(visualElement,transitionEnd)}))}function sortByTreeOrder(a,b){return a.sortNodePosition(b)}function shouldBlockAnimation({protectedKeys:protectedKeys,needsAnimating:needsAnimating},key){const shouldBlock=protectedKeys.hasOwnProperty(key)&&!0!==needsAnimating[key];return needsAnimating[key]=!1,shouldBlock}const variantPriorityOrder=[AnimationType.Animate,AnimationType.InView,AnimationType.Focus,AnimationType.Hover,AnimationType.Tap,AnimationType.Drag,AnimationType.Exit],reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=variantPriorityOrder.length;function animateList(visualElement){return animations=>Promise.all(animations.map((({animation:animation,options:options})=>function animateVisualElement(visualElement,definition,options={}){let animation;if(visualElement.notify("AnimationStart",definition),Array.isArray(definition)){const animations=definition.map((variant=>animateVariant(visualElement,variant,options)));animation=Promise.all(animations)}else if("string"==typeof definition)animation=animateVariant(visualElement,definition,options);else{const resolvedDefinition="function"==typeof definition?resolveVariant(visualElement,definition,options.custom):definition;animation=animateTarget(visualElement,resolvedDefinition,options)}return animation.then((()=>visualElement.notify("AnimationComplete",definition)))}(visualElement,animation,options))))}function createAnimationState(visualElement){let animate=animateList(visualElement);const state=function createState(){return{[AnimationType.Animate]:createTypeState(!0),[AnimationType.InView]:createTypeState(),[AnimationType.Hover]:createTypeState(),[AnimationType.Tap]:createTypeState(),[AnimationType.Drag]:createTypeState(),[AnimationType.Focus]:createTypeState(),[AnimationType.Exit]:createTypeState()}}();let isInitialRender=!0;const buildResolvedTypeValues=(acc,definition)=>{const resolved=resolveVariant(visualElement,definition);if(resolved){const{transition:transition,transitionEnd:transitionEnd,...target}=resolved;acc={...acc,...target,...transitionEnd}}return acc};function animateChanges(options,changedActiveType){var _a;const props=visualElement.getProps(),context=visualElement.getVariantContext(!0)||{},animations=[],removedKeys=new Set;let encounteredKeys={},removedVariantIndex=1/0;for(let i=0;i<numAnimationTypes;i++){const type=reversePriorityOrder[i],typeState=state[type],prop=null!==(_a=props[type])&&void 0!==_a?_a:context[type],propIsVariant=isVariantLabel(prop),activeDelta=type===changedActiveType?typeState.isActive:null;!1===activeDelta&&(removedVariantIndex=i);let isInherited=prop===context[type]&&prop!==props[type]&&propIsVariant;if(isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1),typeState.protectedKeys={...encounteredKeys},!typeState.isActive&&null===activeDelta||!prop&&!typeState.prevProp||isAnimationControls(prop)||"boolean"==typeof prop)continue;const variantDidChange=checkVariantsDidChange(typeState.prevProp,prop);let shouldAnimateType=variantDidChange||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i>removedVariantIndex&&propIsVariant;const definitionList=Array.isArray(prop)?prop:[prop];let resolvedValues=definitionList.reduce(buildResolvedTypeValues,{});!1===activeDelta&&(resolvedValues={});const{prevResolvedValues:prevResolvedValues={}}=typeState,allKeys={...prevResolvedValues,...resolvedValues},markToAnimate=key=>{shouldAnimateType=!0,removedKeys.delete(key),typeState.needsAnimating[key]=!0};for(const key in allKeys){const next=resolvedValues[key],prev=prevResolvedValues[key];encounteredKeys.hasOwnProperty(key)||(next!==prev?isKeyframesTarget(next)&&isKeyframesTarget(prev)?!shallowCompare(next,prev)||variantDidChange?markToAnimate(key):typeState.protectedKeys[key]=!0:void 0!==next?markToAnimate(key):removedKeys.add(key):void 0!==next&&removedKeys.has(key)?markToAnimate(key):typeState.protectedKeys[key]=!0)}typeState.prevProp=prop,typeState.prevResolvedValues=resolvedValues,typeState.isActive&&(encounteredKeys={...encounteredKeys,...resolvedValues}),isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1),shouldAnimateType&&!isInherited&&animations.push(...definitionList.map((animation=>({animation:animation,options:{type:type,...options}}))))}if(removedKeys.size){const fallbackAnimation={};removedKeys.forEach((key=>{const fallbackTarget=visualElement.getBaseTarget(key);void 0!==fallbackTarget&&(fallbackAnimation[key]=fallbackTarget)})),animations.push({animation:fallbackAnimation})}let shouldAnimate=Boolean(animations.length);return isInitialRender&&!1===props.initial&&!visualElement.manuallyAnimateOnMount&&(shouldAnimate=!1),isInitialRender=!1,shouldAnimate?animate(animations):Promise.resolve()}return{animateChanges:animateChanges,setActive:function setActive(type,isActive,options){var _a;if(state[type].isActive===isActive)return Promise.resolve();null===(_a=visualElement.variantChildren)||void 0===_a||_a.forEach((child=>{var _a;return null===(_a=child.animationState)||void 0===_a?void 0:_a.setActive(type,isActive)})),state[type].isActive=isActive;const animations=animateChanges(options,type);for(const key in state)state[key].protectedKeys={};return animations},setAnimateFunction:function setAnimateFunction(makeAnimator){animate=makeAnimator(visualElement)},getState:()=>state}}function checkVariantsDidChange(prev,next){return"string"==typeof next?next!==prev:!!Array.isArray(next)&&!shallowCompare(next,prev)}function createTypeState(isActive=!1){return{isActive:isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}const animations={animation:makeRenderlessComponent((({visualElement:visualElement,animate:animate})=>{visualElement.animationState||(visualElement.animationState=createAnimationState(visualElement)),isAnimationControls(animate)&&(0,react.useEffect)((()=>animate.subscribe(visualElement)),[animate])})),exit:makeRenderlessComponent((props=>{const{custom:custom,visualElement:visualElement}=props,[isPresent,safeToRemove]=usePresence(),presenceContext=(0,react.useContext)(context_PresenceContext.O);(0,react.useEffect)((()=>{visualElement.isPresent=isPresent;const animation=visualElement.animationState&&visualElement.animationState.setActive(AnimationType.Exit,!isPresent,{custom:presenceContext&&presenceContext.custom||custom});animation&&!isPresent&&animation.then(safeToRemove)}),[isPresent])}))},isPoint=point=>point.hasOwnProperty("x")&&point.hasOwnProperty("y"),isPoint3D=point=>isPoint(point)&&point.hasOwnProperty("z"),distance1D=(a,b)=>Math.abs(a-b);class PanSession{constructor(event,handlers,{transformPagePoint:transformPagePoint}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.updatePoint=()=>{if(!this.lastMoveEvent||!this.lastMoveEventInfo)return;const info=getPanInfo(this.lastMoveEventInfo,this.history),isPanStarted=null!==this.startEvent,isDistancePastThreshold=function distance(a,b){if(isNum(a)&&isNum(b))return distance1D(a,b);if(isPoint(a)&&isPoint(b)){const xDelta=distance1D(a.x,b.x),yDelta=distance1D(a.y,b.y),zDelta=isPoint3D(a)&&isPoint3D(b)?distance1D(a.z,b.z):0;return Math.sqrt(Math.pow(xDelta,2)+Math.pow(yDelta,2)+Math.pow(zDelta,2))}}(info.offset,{x:0,y:0})>=3;if(!isPanStarted&&!isDistancePastThreshold)return;const{point:point}=info,{timestamp:timestamp}=(0,es.$B)();this.history.push({...point,timestamp:timestamp});const{onStart:onStart,onMove:onMove}=this.handlers;isPanStarted||(onStart&&onStart(this.lastMoveEvent,info),this.startEvent=this.lastMoveEvent),onMove&&onMove(this.lastMoveEvent,info)},this.handlePointerMove=(event,info)=>{this.lastMoveEvent=event,this.lastMoveEventInfo=transformPoint(info,this.transformPagePoint),isMouseEvent(event)&&0===event.buttons?this.handlePointerUp(event,info):es.ZP.update(this.updatePoint,!0)},this.handlePointerUp=(event,info)=>{this.end();const{onEnd:onEnd,onSessionEnd:onSessionEnd}=this.handlers,panInfo=getPanInfo(transformPoint(info,this.transformPagePoint),this.history);this.startEvent&&onEnd&&onEnd(event,panInfo),onSessionEnd&&onSessionEnd(event,panInfo)},isTouchEvent(event)&&event.touches.length>1)return;this.handlers=handlers,this.transformPagePoint=transformPagePoint;const initialInfo=transformPoint(extractEventInfo(event),this.transformPagePoint),{point:point}=initialInfo,{timestamp:timestamp}=(0,es.$B)();this.history=[{...point,timestamp:timestamp}];const{onSessionStart:onSessionStart}=handlers;onSessionStart&&onSessionStart(event,getPanInfo(initialInfo,this.history)),this.removeListeners=pipe(addPointerEvent(window,"pointermove",this.handlePointerMove),addPointerEvent(window,"pointerup",this.handlePointerUp),addPointerEvent(window,"pointercancel",this.handlePointerUp))}updateHandlers(handlers){this.handlers=handlers}end(){this.removeListeners&&this.removeListeners(),es.qY.update(this.updatePoint)}}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a,b){return{x:a.x-b.x,y:a.y-b.y}}function getPanInfo({point:point},history){return{point:point,delta:subtractPoint(point,lastDevicePoint(history)),offset:subtractPoint(point,startDevicePoint(history)),velocity:PanSession_getVelocity(history,.1)}}function startDevicePoint(history){return history[0]}function lastDevicePoint(history){return history[history.length-1]}function PanSession_getVelocity(history,timeDelta){if(history.length<2)return{x:0,y:0};let i=history.length-1,timestampedPoint=null;const lastPoint=lastDevicePoint(history);for(;i>=0&&(timestampedPoint=history[i],!(lastPoint.timestamp-timestampedPoint.timestamp>secondsToMilliseconds(timeDelta)));)i--;if(!timestampedPoint)return{x:0,y:0};const time=(lastPoint.timestamp-timestampedPoint.timestamp)/1e3;if(0===time)return{x:0,y:0};const currentVelocity={x:(lastPoint.x-timestampedPoint.x)/time,y:(lastPoint.y-timestampedPoint.y)/time};return currentVelocity.x===1/0&&(currentVelocity.x=0),currentVelocity.y===1/0&&(currentVelocity.y=0),currentVelocity}function calcLength(axis){return axis.max-axis.min}function isNear(value,target=0,maxDistance=.01){return Math.abs(value-target)<=maxDistance}function calcAxisDelta(delta,source,target,origin=.5){delta.origin=origin,delta.originPoint=mix(source.min,source.max,delta.origin),delta.scale=calcLength(target)/calcLength(source),(isNear(delta.scale,1,1e-4)||isNaN(delta.scale))&&(delta.scale=1),delta.translate=mix(target.min,target.max,delta.origin)-delta.originPoint,(isNear(delta.translate)||isNaN(delta.translate))&&(delta.translate=0)}function calcBoxDelta(delta,source,target,origin){calcAxisDelta(delta.x,source.x,target.x,null==origin?void 0:origin.originX),calcAxisDelta(delta.y,source.y,target.y,null==origin?void 0:origin.originY)}function calcRelativeAxis(target,relative,parent){target.min=parent.min+relative.min,target.max=target.min+calcLength(relative)}function calcRelativeAxisPosition(target,layout,parent){target.min=layout.min-parent.min,target.max=target.min+calcLength(layout)}function calcRelativePosition(target,layout,parent){calcRelativeAxisPosition(target.x,layout.x,parent.x),calcRelativeAxisPosition(target.y,layout.y,parent.y)}function calcRelativeAxisConstraints(axis,min,max){return{min:void 0!==min?axis.min+min:void 0,max:void 0!==max?axis.max+max-(axis.max-axis.min):void 0}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min,max=constraintsAxis.max-layoutAxis.max;return constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&([min,max]=[max,min]),{min:min,max:max}}const defaultElastic=.35;function resolveAxisElastic(dragElastic,minLabel,maxLabel){return{min:resolvePointElastic(dragElastic,minLabel),max:resolvePointElastic(dragElastic,maxLabel)}}function resolvePointElastic(dragElastic,label){var _a;return"number"==typeof dragElastic?dragElastic:null!==(_a=dragElastic[label])&&void 0!==_a?_a:0}function eachAxis(callback){return[callback("x"),callback("y")]}function convertBoundingBoxToBox({top:top,left:left,right:right,bottom:bottom}){return{x:{min:left,max:right},y:{min:top,max:bottom}}}function isIdentityScale(scale){return void 0===scale||1===scale}function hasScale({scale:scale,scaleX:scaleX,scaleY:scaleY}){return!isIdentityScale(scale)||!isIdentityScale(scaleX)||!isIdentityScale(scaleY)}function hasTransform(values){return hasScale(values)||has2DTranslate(values)||values.z||values.rotate||values.rotateX||values.rotateY}function has2DTranslate(values){return is2DTranslate(values.x)||is2DTranslate(values.y)}function is2DTranslate(value){return value&&"0%"!==value}function scalePoint(point,scale,originPoint){return originPoint+scale*(point-originPoint)}function applyPointDelta(point,translate,scale,originPoint,boxScale){return void 0!==boxScale&&(point=scalePoint(point,boxScale,originPoint)),scalePoint(point,scale,originPoint)+translate}function applyAxisDelta(axis,translate=0,scale=1,originPoint,boxScale){axis.min=applyPointDelta(axis.min,translate,scale,originPoint,boxScale),axis.max=applyPointDelta(axis.max,translate,scale,originPoint,boxScale)}function applyBoxDelta(box,{x:x,y:y}){applyAxisDelta(box.x,x.translate,x.scale,x.originPoint),applyAxisDelta(box.y,y.translate,y.scale,y.originPoint)}function snapToDefault(scale){return Number.isInteger(scale)||scale>1.0000000000001||scale<.999999999999?scale:1}function translateAxis(axis,distance){axis.min=axis.min+distance,axis.max=axis.max+distance}function transformAxis(axis,transforms,[key,scaleKey,originKey]){const axisOrigin=void 0!==transforms[originKey]?transforms[originKey]:.5,originPoint=mix(axis.min,axis.max,axisOrigin);applyAxisDelta(axis,transforms[key],transforms[scaleKey],originPoint,transforms.scale)}const xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];function transformBox(box,transform){transformAxis(box.x,transform,xKeys),transformAxis(box.y,transform,yKeys)}function measureViewportBox(instance,transformPoint){return convertBoundingBoxToBox(function transformBoxPoints(point,transformPoint){if(!transformPoint)return point;const topLeft=transformPoint({x:point.left,y:point.top}),bottomRight=transformPoint({x:point.right,y:point.bottom});return{top:topLeft.y,left:topLeft.x,bottom:bottomRight.y,right:bottomRight.x}}(instance.getBoundingClientRect(),transformPoint))}const elementDragControls=new WeakMap;class VisualElementDragControls{constructor(visualElement){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic={x:{min:0,max:0},y:{min:0,max:0}},this.visualElement=visualElement}start(originEvent,{snapToCursor:snapToCursor=!1}={}){if(!1===this.visualElement.isPresent)return;this.panSession=new PanSession(originEvent,{onSessionStart:event=>{this.stopAnimation(),snapToCursor&&this.snapToCursor(extractEventInfo(event,"page").point)},onStart:(event,info)=>{var _a;const{drag:drag,dragPropagation:dragPropagation,onDragStart:onDragStart}=this.getProps();(!drag||dragPropagation||(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=getGlobalLock(drag),this.openGlobalLock))&&(this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),eachAxis((axis=>{var _a,_b;let current=this.getAxisMotionValue(axis).get()||0;if(percent.test(current)){const measuredAxis=null===(_b=null===(_a=this.visualElement.projection)||void 0===_a?void 0:_a.layout)||void 0===_b?void 0:_b.layoutBox[axis];if(measuredAxis){current=calcLength(measuredAxis)*(parseFloat(current)/100)}}this.originPoint[axis]=current})),null==onDragStart||onDragStart(event,info),null===(_a=this.visualElement.animationState)||void 0===_a||_a.setActive(AnimationType.Drag,!0))},onMove:(event,info)=>{const{dragPropagation:dragPropagation,dragDirectionLock:dragDirectionLock,onDirectionLock:onDirectionLock,onDrag:onDrag}=this.getProps();if(!dragPropagation&&!this.openGlobalLock)return;const{offset:offset}=info;if(dragDirectionLock&&null===this.currentDirection)return this.currentDirection=function getCurrentDirection(offset,lockThreshold=10){let direction=null;Math.abs(offset.y)>lockThreshold?direction="y":Math.abs(offset.x)>lockThreshold&&(direction="x");return direction}(offset),void(null!==this.currentDirection&&(null==onDirectionLock||onDirectionLock(this.currentDirection)));this.updateAxis("x",info.point,offset),this.updateAxis("y",info.point,offset),this.visualElement.render(),null==onDrag||onDrag(event,info)},onSessionEnd:(event,info)=>this.stop(event,info)},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(event,info){const isDragging=this.isDragging;if(this.cancel(),!isDragging)return;const{velocity:velocity}=info;this.startAnimation(velocity);const{onDragEnd:onDragEnd}=this.getProps();null==onDragEnd||onDragEnd(event,info)}cancel(){var _a,_b;this.isDragging=!1,this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!1),null===(_a=this.panSession)||void 0===_a||_a.end(),this.panSession=void 0;const{dragPropagation:dragPropagation}=this.getProps();!dragPropagation&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),null===(_b=this.visualElement.animationState)||void 0===_b||_b.setActive(AnimationType.Drag,!1)}updateAxis(axis,_point,offset){const{drag:drag}=this.getProps();if(!offset||!shouldDrag(axis,drag,this.currentDirection))return;const axisValue=this.getAxisMotionValue(axis);let next=this.originPoint[axis]+offset[axis];this.constraints&&this.constraints[axis]&&(next=function applyConstraints(point,{min:min,max:max},elastic){return void 0!==min&&point<min?point=elastic?mix(min,point,elastic.min):Math.max(point,min):void 0!==max&&point>max&&(point=elastic?mix(max,point,elastic.max):Math.min(point,max)),point}(next,this.constraints[axis],this.elastic[axis])),axisValue.set(next)}resolveConstraints(){const{dragConstraints:dragConstraints,dragElastic:dragElastic}=this.getProps(),{layout:layout}=this.visualElement.projection||{},prevConstraints=this.constraints;dragConstraints&&isRefObject(dragConstraints)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!dragConstraints||!layout)&&function calcRelativeConstraints(layoutBox,{top:top,left:left,bottom:bottom,right:right}){return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)}}(layout.layoutBox,dragConstraints),this.elastic=function resolveDragElastic(dragElastic=defaultElastic){return!1===dragElastic?dragElastic=0:!0===dragElastic&&(dragElastic=defaultElastic),{x:resolveAxisElastic(dragElastic,"left","right"),y:resolveAxisElastic(dragElastic,"top","bottom")}}(dragElastic),prevConstraints!==this.constraints&&layout&&this.constraints&&!this.hasMutatedConstraints&&eachAxis((axis=>{this.getAxisMotionValue(axis)&&(this.constraints[axis]=function rebaseAxisConstraints(layout,constraints){const relativeConstraints={};return void 0!==constraints.min&&(relativeConstraints.min=constraints.min-layout.min),void 0!==constraints.max&&(relativeConstraints.max=constraints.max-layout.min),relativeConstraints}(layout.layoutBox[axis],this.constraints[axis]))}))}resolveRefConstraints(){const{dragConstraints:constraints,onMeasureDragConstraints:onMeasureDragConstraints}=this.getProps();if(!constraints||!isRefObject(constraints))return!1;const constraintsElement=constraints.current,{projection:projection}=this.visualElement;if(!projection||!projection.layout)return!1;const constraintsBox=function measurePageBox(element,rootProjectionNode,transformPagePoint){const viewportBox=measureViewportBox(element,transformPagePoint),{scroll:scroll}=rootProjectionNode;return scroll&&(translateAxis(viewportBox.x,scroll.offset.x),translateAxis(viewportBox.y,scroll.offset.y)),viewportBox}(constraintsElement,projection.root,this.visualElement.getTransformPagePoint());let measuredConstraints=function calcViewportConstraints(layoutBox,constraintsBox){return{x:calcViewportAxisConstraints(layoutBox.x,constraintsBox.x),y:calcViewportAxisConstraints(layoutBox.y,constraintsBox.y)}}(projection.layout.layoutBox,constraintsBox);if(onMeasureDragConstraints){const userConstraints=onMeasureDragConstraints(function convertBoxToBoundingBox({x:x,y:y}){return{top:y.min,right:x.max,bottom:y.max,left:x.min}}(measuredConstraints));this.hasMutatedConstraints=!!userConstraints,userConstraints&&(measuredConstraints=convertBoundingBoxToBox(userConstraints))}return measuredConstraints}startAnimation(velocity){const{drag:drag,dragMomentum:dragMomentum,dragElastic:dragElastic,dragTransition:dragTransition,dragSnapToOrigin:dragSnapToOrigin,onDragTransitionEnd:onDragTransitionEnd}=this.getProps(),constraints=this.constraints||{},momentumAnimations=eachAxis((axis=>{var _a;if(!shouldDrag(axis,drag,this.currentDirection))return;let transition=null!==(_a=null==constraints?void 0:constraints[axis])&&void 0!==_a?_a:{};dragSnapToOrigin&&(transition={min:0,max:0});const bounceStiffness=dragElastic?200:1e6,bounceDamping=dragElastic?40:1e7,inertia={type:"inertia",velocity:dragMomentum?velocity[axis]:0,bounceStiffness:bounceStiffness,bounceDamping:bounceDamping,timeConstant:750,restDelta:1,restSpeed:10,...dragTransition,...transition};return this.startAxisValueAnimation(axis,inertia)}));return Promise.all(momentumAnimations).then(onDragTransitionEnd)}startAxisValueAnimation(axis,transition){return startAnimation(axis,this.getAxisMotionValue(axis),0,transition)}stopAnimation(){eachAxis((axis=>this.getAxisMotionValue(axis).stop()))}getAxisMotionValue(axis){var _a,_b;const dragKey="_drag"+axis.toUpperCase(),externalMotionValue=this.visualElement.getProps()[dragKey];return externalMotionValue||this.visualElement.getValue(axis,null!==(_b=null===(_a=this.visualElement.getProps().initial)||void 0===_a?void 0:_a[axis])&&void 0!==_b?_b:0)}snapToCursor(point){eachAxis((axis=>{const{drag:drag}=this.getProps();if(!shouldDrag(axis,drag,this.currentDirection))return;const{projection:projection}=this.visualElement,axisValue=this.getAxisMotionValue(axis);if(projection&&projection.layout){const{min:min,max:max}=projection.layout.layoutBox[axis];axisValue.set(point[axis]-mix(min,max,.5))}}))}scalePositionWithinConstraints(){var _a;if(!this.visualElement.current)return;const{drag:drag,dragConstraints:dragConstraints}=this.getProps(),{projection:projection}=this.visualElement;if(!isRefObject(dragConstraints)||!projection||!this.constraints)return;this.stopAnimation();const boxProgress={x:0,y:0};eachAxis((axis=>{const axisValue=this.getAxisMotionValue(axis);if(axisValue){const latest=axisValue.get();boxProgress[axis]=function constraints_calcOrigin(source,target){let origin=.5;const sourceLength=calcLength(source),targetLength=calcLength(target);return targetLength>sourceLength?origin=progress(target.min,target.max-sourceLength,source.min):sourceLength>targetLength&&(origin=progress(source.min,source.max-targetLength,target.min)),clamp_clamp(0,1,origin)}({min:latest,max:latest},this.constraints[axis])}}));const{transformTemplate:transformTemplate}=this.visualElement.getProps();this.visualElement.current.style.transform=transformTemplate?transformTemplate({},""):"none",null===(_a=projection.root)||void 0===_a||_a.updateScroll(),projection.updateLayout(),this.resolveConstraints(),eachAxis((axis=>{if(!shouldDrag(axis,drag,null))return;const axisValue=this.getAxisMotionValue(axis),{min:min,max:max}=this.constraints[axis];axisValue.set(mix(min,max,boxProgress[axis]))}))}addListeners(){var _a;if(!this.visualElement.current)return;elementDragControls.set(this.visualElement,this);const stopPointerListener=addPointerEvent(this.visualElement.current,"pointerdown",(event=>{const{drag:drag,dragListener:dragListener=!0}=this.getProps();drag&&dragListener&&this.start(event)})),measureDragConstraints=()=>{const{dragConstraints:dragConstraints}=this.getProps();isRefObject(dragConstraints)&&(this.constraints=this.resolveRefConstraints())},{projection:projection}=this.visualElement,stopMeasureLayoutListener=projection.addEventListener("measure",measureDragConstraints);projection&&!projection.layout&&(null===(_a=projection.root)||void 0===_a||_a.updateScroll(),projection.updateLayout()),measureDragConstraints();const stopResizeListener=addDomEvent(window,"resize",(()=>this.scalePositionWithinConstraints())),stopLayoutUpdateListener=projection.addEventListener("didUpdate",(({delta:delta,hasLayoutChanged:hasLayoutChanged})=>{this.isDragging&&hasLayoutChanged&&(eachAxis((axis=>{const motionValue=this.getAxisMotionValue(axis);motionValue&&(this.originPoint[axis]+=delta[axis].translate,motionValue.set(motionValue.get()+delta[axis].translate))})),this.visualElement.render())}));return()=>{stopResizeListener(),stopPointerListener(),stopMeasureLayoutListener(),null==stopLayoutUpdateListener||stopLayoutUpdateListener()}}getProps(){const props=this.visualElement.getProps(),{drag:drag=!1,dragDirectionLock:dragDirectionLock=!1,dragPropagation:dragPropagation=!1,dragConstraints:dragConstraints=!1,dragElastic:dragElastic=defaultElastic,dragMomentum:dragMomentum=!0}=props;return{...props,drag:drag,dragDirectionLock:dragDirectionLock,dragPropagation:dragPropagation,dragConstraints:dragConstraints,dragElastic:dragElastic,dragMomentum:dragMomentum}}}function shouldDrag(direction,drag,currentDirection){return!(!0!==drag&&drag!==direction||null!==currentDirection&&currentDirection!==direction)}const drag={pan:makeRenderlessComponent((function usePanGesture({onPan:onPan,onPanStart:onPanStart,onPanEnd:onPanEnd,onPanSessionStart:onPanSessionStart,visualElement:visualElement}){const hasPanEvents=onPan||onPanStart||onPanEnd||onPanSessionStart,panSession=(0,react.useRef)(null),{transformPagePoint:transformPagePoint}=(0,react.useContext)(MotionConfigContext),handlers={onSessionStart:onPanSessionStart,onStart:onPanStart,onMove:onPan,onEnd:(event,info)=>{panSession.current=null,onPanEnd&&onPanEnd(event,info)}};(0,react.useEffect)((()=>{null!==panSession.current&&panSession.current.updateHandlers(handlers)})),usePointerEvent(visualElement,"pointerdown",hasPanEvents&&function onPointerDown(event){panSession.current=new PanSession(event,handlers,{transformPagePoint:transformPagePoint})}),(0,use_unmount_effect.z)((()=>panSession.current&&panSession.current.end()))})),drag:makeRenderlessComponent((function useDrag(props){const{dragControls:groupDragControls,visualElement:visualElement}=props,dragControls=(0,use_constant.h)((()=>new VisualElementDragControls(visualElement)));(0,react.useEffect)((()=>groupDragControls&&groupDragControls.subscribe(dragControls)),[dragControls,groupDragControls]),(0,react.useEffect)((()=>dragControls.addListeners()),[dragControls])}))};function css_variables_conversion_isCSSVariable(value){return"string"==typeof value&&value.startsWith("var(--")}const cssVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function getVariableValue(current,element,depth=1){const[token,fallback]=function parseCSSVariable(current){const match=cssVariableRegex.exec(current);if(!match)return[,];const[,token,fallback]=match;return[token,fallback]}(current);if(!token)return;const resolved=window.getComputedStyle(element).getPropertyValue(token);return resolved?resolved.trim():css_variables_conversion_isCSSVariable(fallback)?getVariableValue(fallback,element,depth+1):fallback}const positionalKeys=new Set(["width","height","top","left","right","bottom","x","y"]),isPositionalKey=key=>positionalKeys.has(key),setAndResetVelocity=(value,to)=>{value.set(to,!1),value.set(to)},isNumOrPxType=v=>v===number||v===px;var BoundingBoxDimension;!function(BoundingBoxDimension){BoundingBoxDimension.width="width",BoundingBoxDimension.height="height",BoundingBoxDimension.left="left",BoundingBoxDimension.right="right",BoundingBoxDimension.top="top",BoundingBoxDimension.bottom="bottom"}(BoundingBoxDimension||(BoundingBoxDimension={}));const getPosFromMatrix=(matrix,pos)=>parseFloat(matrix.split(", ")[pos]),getTranslateFromMatrix=(pos2,pos3)=>(_bbox,{transform:transform})=>{if("none"===transform||!transform)return 0;const matrix3d=transform.match(/^matrix3d\((.+)\)$/);if(matrix3d)return getPosFromMatrix(matrix3d[1],pos3);{const matrix=transform.match(/^matrix\((.+)\)$/);return matrix?getPosFromMatrix(matrix[1],pos2):0}},transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter((key=>!transformKeys.has(key)));const positionalValues={width:({x:x},{paddingLeft:paddingLeft="0",paddingRight:paddingRight="0"})=>x.max-x.min-parseFloat(paddingLeft)-parseFloat(paddingRight),height:({y:y},{paddingTop:paddingTop="0",paddingBottom:paddingBottom="0"})=>y.max-y.min-parseFloat(paddingTop)-parseFloat(paddingBottom),top:(_bbox,{top:top})=>parseFloat(top),left:(_bbox,{left:left})=>parseFloat(left),bottom:({y:y},{top:top})=>parseFloat(top)+(y.max-y.min),right:({x:x},{left:left})=>parseFloat(left)+(x.max-x.min),x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)},checkAndConvertChangedValueTypes=(visualElement,target,origin={},transitionEnd={})=>{target={...target},transitionEnd={...transitionEnd};const targetPositionalKeys=Object.keys(target).filter(isPositionalKey);let removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1;const changedValueTypeKeys=[];if(targetPositionalKeys.forEach((key=>{const value=visualElement.getValue(key);if(!visualElement.hasValue(key))return;let from=origin[key],fromType=findDimensionValueType(from);const to=target[key];let toType;if(isKeyframesTarget(to)){const numKeyframes=to.length,fromIndex=null===to[0]?1:0;from=to[fromIndex],fromType=findDimensionValueType(from);for(let i=fromIndex;i<numKeyframes;i++)toType?findDimensionValueType(to[i]):(toType=findDimensionValueType(to[i]),toType===fromType||isNumOrPxType(fromType)&&isNumOrPxType(toType))}else toType=findDimensionValueType(to);if(fromType!==toType)if(isNumOrPxType(fromType)&&isNumOrPxType(toType)){const current=value.get();"string"==typeof current&&value.set(parseFloat(current)),"string"==typeof to?target[key]=parseFloat(to):Array.isArray(to)&&toType===px&&(target[key]=to.map(parseFloat))}else(null==fromType?void 0:fromType.transform)&&(null==toType?void 0:toType.transform)&&(0===from||0===to)?0===from?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=function removeNonTranslationalTransform(visualElement){const removedTransforms=[];return nonTranslationalTransformKeys.forEach((key=>{const value=visualElement.getValue(key);void 0!==value&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith("scale")?1:0))})),removedTransforms.length&&visualElement.render(),removedTransforms}(visualElement),hasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=void 0!==transitionEnd[key]?transitionEnd[key]:target[key],setAndResetVelocity(value,to))})),changedValueTypeKeys.length){const scrollY=changedValueTypeKeys.indexOf("height")>=0?window.pageYOffset:null,convertedTarget=((target,visualElement,changedKeys)=>{const originBbox=visualElement.measureViewportBox(),element=visualElement.current,elementComputedStyle=getComputedStyle(element),{display:display}=elementComputedStyle,origin={};"none"===display&&visualElement.setStaticValue("display",target.display||"block"),changedKeys.forEach((key=>{origin[key]=positionalValues[key](originBbox,elementComputedStyle)})),visualElement.render();const targetBbox=visualElement.measureViewportBox();return changedKeys.forEach((key=>{const value=visualElement.getValue(key);setAndResetVelocity(value,origin[key]),target[key]=positionalValues[key](targetBbox,elementComputedStyle)})),target})(target,visualElement,changedValueTypeKeys);return removedTransformValues.length&&removedTransformValues.forEach((([key,value])=>{visualElement.getValue(key).set(value)})),visualElement.render(),is_browser.j&&null!==scrollY&&window.scrollTo({top:scrollY}),{target:convertedTarget,transitionEnd:transitionEnd}}return{target:target,transitionEnd:transitionEnd}};function unitConversion(visualElement,target,origin,transitionEnd){return(target=>Object.keys(target).some(isPositionalKey))(target)?checkAndConvertChangedValueTypes(visualElement,target,origin,transitionEnd):{target:target,transitionEnd:transitionEnd}}const parseDomVariant=(visualElement,target,origin,transitionEnd)=>{const resolved=function resolveCSSVariables(visualElement,{...target},transitionEnd){const element=visualElement.current;if(!(element instanceof Element))return{target:target,transitionEnd:transitionEnd};transitionEnd&&(transitionEnd={...transitionEnd}),visualElement.values.forEach((value=>{const current=value.get();if(!css_variables_conversion_isCSSVariable(current))return;const resolved=getVariableValue(current,element);resolved&&value.set(resolved)}));for(const key in target){const current=target[key];if(!css_variables_conversion_isCSSVariable(current))continue;const resolved=getVariableValue(current,element);resolved&&(target[key]=resolved,transitionEnd&&void 0===transitionEnd[key]&&(transitionEnd[key]=current))}return{target:target,transitionEnd:transitionEnd}}(visualElement,target,transitionEnd);return unitConversion(visualElement,target=resolved.target,origin,transitionEnd=resolved.transitionEnd)};var reduced_motion=__webpack_require__("./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs"),state=__webpack_require__("./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs");const featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,propEventHandlers=["AnimationStart","AnimationComplete","Update","Unmount","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];const VisualElement_variantProps=["initial",...variantPriorityOrder],numVariantProps=VisualElement_variantProps.length;class DOMVisualElement extends class VisualElement{constructor({parent:parent,props:props,reducedMotionConfig:reducedMotionConfig,visualState:visualState},options={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.isPresent=!0,this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>es.ZP.render(this.render,!1,!0);const{latestValues:latestValues,renderState:renderState}=visualState;this.latestValues=latestValues,this.baseTarget={...latestValues},this.initialValues=props.initial?{...latestValues}:{},this.renderState=renderState,this.parent=parent,this.props=props,this.depth=parent?parent.depth+1:0,this.reducedMotionConfig=reducedMotionConfig,this.options=options,this.isControllingVariants=isControllingVariants(props),this.isVariantNode=isVariantNode(props),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(parent&&parent.current);const{willChange:willChange,...initialMotionValues}=this.scrapeMotionValuesFromProps(props);for(const key in initialMotionValues){const value=initialMotionValues[key];void 0!==latestValues[key]&&isMotionValue(value)&&(value.set(latestValues[key],!1),isWillChangeMotionValue(willChange)&&willChange.add(key))}}scrapeMotionValuesFromProps(_props){return{}}mount(instance){var _a;this.current=instance,this.projection&&this.projection.mount(instance),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=null===(_a=this.parent)||void 0===_a?void 0:_a.addVariantChild(this)),this.values.forEach(((value,key)=>this.bindToMotionValue(key,value))),state.O.current||(0,reduced_motion.A)(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&&("always"===this.reducedMotionConfig||state.n.current),this.parent&&this.parent.children.add(this),this.setProps(this.props)}unmount(){var _a,_b,_c;null===(_a=this.projection)||void 0===_a||_a.unmount(),es.qY.update(this.notifyUpdate),es.qY.render(this.render),this.valueSubscriptions.forEach((remove=>remove())),null===(_b=this.removeFromVariantTree)||void 0===_b||_b.call(this),null===(_c=this.parent)||void 0===_c||_c.children.delete(this);for(const key in this.events)this.events[key].clear();this.current=null}bindToMotionValue(key,value){const valueIsTransform=transformProps.has(key),removeOnChange=value.onChange((latestValue=>{this.latestValues[key]=latestValue,this.props.onUpdate&&es.ZP.update(this.notifyUpdate,!1,!0),valueIsTransform&&this.projection&&(this.projection.isTransformDirty=!0)})),removeOnRenderRequest=value.onRenderRequest(this.scheduleRender);this.valueSubscriptions.set(key,(()=>{removeOnChange(),removeOnRenderRequest()}))}sortNodePosition(other){return this.current&&this.sortInstanceNodePosition&&this.type===other.type?this.sortInstanceNodePosition(this.current,other.current):0}loadFeatures(renderedProps,isStrict,preloadedFeatures,projectionId,ProjectionNodeConstructor,initialLayoutGroupConfig){const features=[];process.O;for(let i=0;i<numFeatures;i++){const name=featureNames[i],{isEnabled:isEnabled,Component:Component}=featureDefinitions[name];isEnabled(renderedProps)&&Component&&features.push((0,react.createElement)(Component,{key:name,...renderedProps,visualElement:this}))}if(!this.projection&&ProjectionNodeConstructor){this.projection=new ProjectionNodeConstructor(projectionId,this.latestValues,this.parent&&this.parent.projection);const{layoutId:layoutId,layout:layout,drag:drag,dragConstraints:dragConstraints,layoutScroll:layoutScroll}=renderedProps;this.projection.setOptions({layoutId:layoutId,layout:layout,alwaysMeasureLayout:Boolean(drag)||dragConstraints&&isRefObject(dragConstraints),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:"string"==typeof layout?layout:"both",initialPromotionConfig:initialLayoutGroupConfig,layoutScroll:layoutScroll})}return features}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}getStaticValue(key){return this.latestValues[key]}setStaticValue(key,value){this.latestValues[key]=value}makeTargetAnimatable(target,canMutate=!0){return this.makeTargetAnimatableFromInstance(target,this.props,canMutate)}setProps(props){(props.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.props=props;for(let i=0;i<propEventHandlers.length;i++){const key=propEventHandlers[i];this.propEventSubscriptions[key]&&(this.propEventSubscriptions[key](),delete this.propEventSubscriptions[key]);const listener=props["on"+key];listener&&(this.propEventSubscriptions[key]=this.on(key,listener))}this.prevMotionValues=function updateMotionValuesFromProps(element,next,prev){const{willChange:willChange}=next;for(const key in next){const nextValue=next[key],prevValue=prev[key];if(isMotionValue(nextValue))element.addValue(key,nextValue),isWillChangeMotionValue(willChange)&&willChange.add(key);else if(isMotionValue(prevValue))element.addValue(key,motionValue(nextValue)),isWillChangeMotionValue(willChange)&&willChange.remove(key);else if(prevValue!==nextValue)if(element.hasValue(key)){const existingValue=element.getValue(key);!existingValue.hasAnimated&&existingValue.set(nextValue)}else{const latestValue=element.getStaticValue(key);element.addValue(key,motionValue(void 0!==latestValue?latestValue:nextValue))}}for(const key in prev)void 0===next[key]&&element.removeValue(key);return next}(this,this.scrapeMotionValuesFromProps(props),this.prevMotionValues)}getProps(){return this.props}getVariant(name){var _a;return null===(_a=this.props.variants)||void 0===_a?void 0:_a[name]}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){var _a;return this.isVariantNode?this:null===(_a=this.parent)||void 0===_a?void 0:_a.getClosestVariantNode()}getVariantContext(startAtParent=!1){var _a,_b;if(startAtParent)return null===(_a=this.parent)||void 0===_a?void 0:_a.getVariantContext();if(!this.isControllingVariants){const context=(null===(_b=this.parent)||void 0===_b?void 0:_b.getVariantContext())||{};return void 0!==this.props.initial&&(context.initial=this.props.initial),context}const context={};for(let i=0;i<numVariantProps;i++){const name=VisualElement_variantProps[i],prop=this.props[name];(isVariantLabel(prop)||!1===prop)&&(context[name]=prop)}return context}addVariantChild(child){var _a;const closestVariantNode=this.getClosestVariantNode();if(closestVariantNode)return null===(_a=closestVariantNode.variantChildren)||void 0===_a||_a.add(child),()=>closestVariantNode.variantChildren.delete(child)}addValue(key,value){this.hasValue(key)&&this.removeValue(key),this.values.set(key,value),this.latestValues[key]=value.get(),this.bindToMotionValue(key,value)}removeValue(key){var _a;this.values.delete(key),null===(_a=this.valueSubscriptions.get(key))||void 0===_a||_a(),this.valueSubscriptions.delete(key),delete this.latestValues[key],this.removeValueFromRenderState(key,this.renderState)}hasValue(key){return this.values.has(key)}getValue(key,defaultValue){if(this.props.values&&this.props.values[key])return this.props.values[key];let value=this.values.get(key);return void 0===value&&void 0!==defaultValue&&(value=motionValue(defaultValue),this.addValue(key,value)),value}readValue(key){return void 0===this.latestValues[key]&&this.current?this.readValueFromInstance(this.current,key,this.options):this.latestValues[key]}setBaseTarget(key,value){this.baseTarget[key]=value}getBaseTarget(key){var _a;const{initial:initial}=this.props,valueFromInitial="string"==typeof initial||"object"==typeof initial?null===(_a=resolveVariantFromProps(this.props,initial))||void 0===_a?void 0:_a[key]:void 0;if(initial&&void 0!==valueFromInitial)return valueFromInitial;const target=this.getBaseTargetFromProps(this.props,key);return void 0===target||isMotionValue(target)?void 0!==this.initialValues[key]&&void 0===valueFromInitial?void 0:this.baseTarget[key]:target}on(eventName,callback){return this.events[eventName]||(this.events[eventName]=new SubscriptionManager),this.events[eventName].add(callback)}notify(eventName,...args){var _a;null===(_a=this.events[eventName])||void 0===_a||_a.notify(...args)}}{sortInstanceNodePosition(a,b){return 2&a.compareDocumentPosition(b)?1:-1}getBaseTargetFromProps(props,key){var _a;return null===(_a=props.style)||void 0===_a?void 0:_a[key]}removeValueFromRenderState(key,{vars:vars,style:style}){delete vars[key],delete style[key]}makeTargetAnimatableFromInstance({transition:transition,transitionEnd:transitionEnd,...target},{transformValues:transformValues},isMounted){let origin=function getOrigin(target,transition,visualElement){var _a;const origin={};for(const key in target){const transitionOrigin=getOriginFromTransition(key,transition);origin[key]=void 0!==transitionOrigin?transitionOrigin:null===(_a=visualElement.getValue(key))||void 0===_a?void 0:_a.get()}return origin}(target,transition||{},this);if(transformValues&&(transitionEnd&&(transitionEnd=transformValues(transitionEnd)),target&&(target=transformValues(target)),origin&&(origin=transformValues(origin))),isMounted){!function checkTargetForNewValues(visualElement,target,origin){var _a,_b;const newValueKeys=Object.keys(target).filter((key=>!visualElement.hasValue(key))),numNewValues=newValueKeys.length;if(numNewValues)for(let i=0;i<numNewValues;i++){const key=newValueKeys[i],targetValue=target[key];let value=null;Array.isArray(targetValue)&&(value=targetValue[0]),null===value&&(value=null!==(_b=null!==(_a=origin[key])&&void 0!==_a?_a:visualElement.readValue(key))&&void 0!==_b?_b:target[key]),null!=value&&("string"==typeof value&&(/^\-?\d*\.?\d+$/.test(value)||isZeroValueString(value))?value=parseFloat(value):!findValueType(value)&&complex.test(targetValue)&&(value=animatable_none_getAnimatableNone(key,targetValue)),visualElement.addValue(key,motionValue(value)),void 0===origin[key]&&(origin[key]=value),null!==value&&visualElement.setBaseTarget(key,value))}}(this,target,origin);const parsed=parseDomVariant(this,target,origin,transitionEnd);transitionEnd=parsed.transitionEnd,target=parsed.target}return{transition:transition,transitionEnd:transitionEnd,...target}}}class HTMLVisualElement extends DOMVisualElement{readValueFromInstance(instance,key){if(transformProps.has(key)){const defaultType=getDefaultValueType(key);return defaultType&&defaultType.default||0}{const computedStyle=function HTMLVisualElement_getComputedStyle(element){return window.getComputedStyle(element)}(instance),value=(isCSSVariable(key)?computedStyle.getPropertyValue(key):computedStyle[key])||0;return"string"==typeof value?value.trim():value}}measureInstanceViewportBox(instance,{transformPagePoint:transformPagePoint}){return measureViewportBox(instance,transformPagePoint)}build(renderState,latestValues,options,props){buildHTMLStyles(renderState,latestValues,options,props.transformTemplate)}scrapeMotionValuesFromProps(props){return scrapeMotionValuesFromProps(props)}renderInstance(instance,renderState,styleProp,projection){renderHTML(instance,renderState,styleProp,projection)}}class SVGVisualElement extends DOMVisualElement{getBaseTargetFromProps(props,key){return props[key]}readValueFromInstance(instance,key){var _a;return transformProps.has(key)?(null===(_a=getDefaultValueType(key))||void 0===_a?void 0:_a.default)||0:(key=camelCaseAttributes.has(key)?key:camelToDash(key),instance.getAttribute(key))}measureInstanceViewportBox(){return{x:{min:0,max:0},y:{min:0,max:0}}}scrapeMotionValuesFromProps(props){return scrape_motion_values_scrapeMotionValuesFromProps(props)}build(renderState,latestValues,options,props){buildSVGAttrs(renderState,latestValues,options,props.transformTemplate)}renderInstance(instance,renderState,styleProp,projection){renderSVG(instance,renderState,0,projection)}}const create_visual_element_createDomVisualElement=(Component,options)=>isSVGComponent(Component)?new SVGVisualElement(options,{enableHardwareAcceleration:!1}):new HTMLVisualElement(options,{enableHardwareAcceleration:!0});function pixelsToPercent(pixels,axis){return axis.max===axis.min?0:pixels/(axis.max-axis.min)*100}const correctBorderRadius={correct:(latest,node)=>{if(!node.target)return latest;if("string"==typeof latest){if(!px.test(latest))return latest;latest=parseFloat(latest)}return`${pixelsToPercent(latest,node.target.x)}% ${pixelsToPercent(latest,node.target.y)}%`}},correctBoxShadow={correct:(latest,{treeScale:treeScale,projectionDelta:projectionDelta})=>{const original=latest,containsCSSVariables=latest.includes("var("),cssVariables=[];containsCSSVariables&&(latest=latest.replace(cssVariableRegex,(match=>(cssVariables.push(match),"_$css"))));const shadow=complex.parse(latest);if(shadow.length>5)return original;const template=complex.createTransformer(latest),offset="number"!=typeof shadow[0]?1:0,xScale=projectionDelta.x.scale*treeScale.x,yScale=projectionDelta.y.scale*treeScale.y;shadow[0+offset]/=xScale,shadow[1+offset]/=yScale;const averageScale=mix(xScale,yScale,.5);"number"==typeof shadow[2+offset]&&(shadow[2+offset]/=averageScale),"number"==typeof shadow[3+offset]&&(shadow[3+offset]/=averageScale);let output=template(shadow);if(containsCSSVariables){let i=0;output=output.replace("_$css",(()=>{const cssVariable=cssVariables[i];return i++,cssVariable}))}return output}};class MeasureLayoutWithContext extends react.Component{componentDidMount(){const{visualElement:visualElement,layoutGroup:layoutGroup,switchLayoutGroup:switchLayoutGroup,layoutId:layoutId}=this.props,{projection:projection}=visualElement;!function addScaleCorrector(correctors){Object.assign(scaleCorrectors,correctors)}(defaultScaleCorrectors),projection&&(layoutGroup.group&&layoutGroup.group.add(projection),switchLayoutGroup&&switchLayoutGroup.register&&layoutId&&switchLayoutGroup.register(projection),projection.root.didUpdate(),projection.addEventListener("animationComplete",(()=>{this.safeToRemove()})),projection.setOptions({...projection.options,onExitComplete:()=>this.safeToRemove()})),globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(prevProps){const{layoutDependency:layoutDependency,visualElement:visualElement,drag:drag,isPresent:isPresent}=this.props,projection=visualElement.projection;return projection?(projection.isPresent=isPresent,drag||prevProps.layoutDependency!==layoutDependency||void 0===layoutDependency?projection.willUpdate():this.safeToRemove(),prevProps.isPresent!==isPresent&&(isPresent?projection.promote():projection.relegate()||es.ZP.postRender((()=>{var _a;(null===(_a=projection.getStack())||void 0===_a?void 0:_a.members.length)||this.safeToRemove()}))),null):null}componentDidUpdate(){const{projection:projection}=this.props.visualElement;projection&&(projection.root.didUpdate(),!projection.currentAnimation&&projection.isLead()&&this.safeToRemove())}componentWillUnmount(){const{visualElement:visualElement,layoutGroup:layoutGroup,switchLayoutGroup:promoteContext}=this.props,{projection:projection}=visualElement;projection&&(projection.scheduleCheckAfterUnmount(),(null==layoutGroup?void 0:layoutGroup.group)&&layoutGroup.group.remove(projection),(null==promoteContext?void 0:promoteContext.deregister)&&promoteContext.deregister(projection))}safeToRemove(){const{safeToRemove:safeToRemove}=this.props;null==safeToRemove||safeToRemove()}render(){return null}}const defaultScaleCorrectors={borderRadius:{...correctBorderRadius,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:correctBoxShadow},layoutFeatures={measureLayout:function MeasureLayout(props){const[isPresent,safeToRemove]=usePresence(),layoutGroup=(0,react.useContext)(LayoutGroupContext.p);return react.createElement(MeasureLayoutWithContext,{...props,layoutGroup:layoutGroup,switchLayoutGroup:(0,react.useContext)(SwitchLayoutGroupContext),isPresent:isPresent,safeToRemove:safeToRemove})}};const borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=value=>"string"==typeof value?parseFloat(value):value,isPx=value=>"number"==typeof value||px.test(value);function getRadius(values,radiusName){var _a;return null!==(_a=values[radiusName])&&void 0!==_a?_a:values.borderRadius}const easeCrossfadeIn=compress(0,.5,circOut),easeCrossfadeOut=compress(.5,.95,linear);function compress(min,max,easing){return p=>p<min?0:p>max?1:easing(progress(min,max,p))}function copyAxisInto(axis,originAxis){axis.min=originAxis.min,axis.max=originAxis.max}function copyBoxInto(box,originBox){copyAxisInto(box.x,originBox.x),copyAxisInto(box.y,originBox.y)}function removePointDelta(point,translate,scale,originPoint,boxScale){return point=scalePoint(point-=translate,1/scale,originPoint),void 0!==boxScale&&(point=scalePoint(point,1/boxScale,originPoint)),point}function removeAxisTransforms(axis,transforms,[key,scaleKey,originKey],origin,sourceAxis){!function removeAxisDelta(axis,translate=0,scale=1,origin=.5,boxScale,originAxis=axis,sourceAxis=axis){percent.test(translate)&&(translate=parseFloat(translate),translate=mix(sourceAxis.min,sourceAxis.max,translate/100)-sourceAxis.min);if("number"!=typeof translate)return;let originPoint=mix(originAxis.min,originAxis.max,origin);axis===originAxis&&(originPoint-=translate),axis.min=removePointDelta(axis.min,translate,scale,originPoint,boxScale),axis.max=removePointDelta(axis.max,translate,scale,originPoint,boxScale)}(axis,transforms[key],transforms[scaleKey],transforms[originKey],transforms.scale,origin,sourceAxis)}const delta_remove_xKeys=["x","scaleX","originX"],delta_remove_yKeys=["y","scaleY","originY"];function removeBoxTransforms(box,transforms,originBox,sourceBox){removeAxisTransforms(box.x,transforms,delta_remove_xKeys,null==originBox?void 0:originBox.x,null==sourceBox?void 0:sourceBox.x),removeAxisTransforms(box.y,transforms,delta_remove_yKeys,null==originBox?void 0:originBox.y,null==sourceBox?void 0:sourceBox.y)}function isAxisDeltaZero(delta){return 0===delta.translate&&1===delta.scale}function isDeltaZero(delta){return isAxisDeltaZero(delta.x)&&isAxisDeltaZero(delta.y)}function boxEquals(a,b){return a.x.min===b.x.min&&a.x.max===b.x.max&&a.y.min===b.y.min&&a.y.max===b.y.max}function aspectRatio(box){return calcLength(box.x)/calcLength(box.y)}class NodeStack{constructor(){this.members=[]}add(node){addUniqueItem(this.members,node),node.scheduleRender()}remove(node){if(removeItem(this.members,node),node===this.prevLead&&(this.prevLead=void 0),node===this.lead){const prevLead=this.members[this.members.length-1];prevLead&&this.promote(prevLead)}}relegate(node){const indexOfNode=this.members.findIndex((member=>node===member));if(0===indexOfNode)return!1;let prevLead;for(let i=indexOfNode;i>=0;i--){const member=this.members[i];if(!1!==member.isPresent){prevLead=member;break}}return!!prevLead&&(this.promote(prevLead),!0)}promote(node,preserveFollowOpacity){var _a;const prevLead=this.lead;if(node!==prevLead&&(this.prevLead=prevLead,this.lead=node,node.show(),prevLead)){prevLead.instance&&prevLead.scheduleRender(),node.scheduleRender(),node.resumeFrom=prevLead,preserveFollowOpacity&&(node.resumeFrom.preserveOpacity=!0),prevLead.snapshot&&(node.snapshot=prevLead.snapshot,node.snapshot.latestValues=prevLead.animationValues||prevLead.latestValues),(null===(_a=node.root)||void 0===_a?void 0:_a.isUpdating)&&(node.isLayoutDirty=!0);const{crossfade:crossfade}=node.options;!1===crossfade&&prevLead.hide()}}exitAnimationComplete(){this.members.forEach((node=>{var _a,_b,_c,_d,_e;null===(_b=(_a=node.options).onExitComplete)||void 0===_b||_b.call(_a),null===(_e=null===(_c=node.resumingFrom)||void 0===_c?void 0:(_d=_c.options).onExitComplete)||void 0===_e||_e.call(_d)}))}scheduleRender(){this.members.forEach((node=>{node.instance&&node.scheduleRender(!1)}))}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function buildProjectionTransform(delta,treeScale,latestTransform){let transform="";const xTranslate=delta.x.translate/treeScale.x,yTranslate=delta.y.translate/treeScale.y;if((xTranslate||yTranslate)&&(transform=`translate3d(${xTranslate}px, ${yTranslate}px, 0) `),1===treeScale.x&&1===treeScale.y||(transform+=`scale(${1/treeScale.x}, ${1/treeScale.y}) `),latestTransform){const{rotate:rotate,rotateX:rotateX,rotateY:rotateY}=latestTransform;rotate&&(transform+=`rotate(${rotate}deg) `),rotateX&&(transform+=`rotateX(${rotateX}deg) `),rotateY&&(transform+=`rotateY(${rotateY}deg) `)}const elementScaleX=delta.x.scale*treeScale.x,elementScaleY=delta.y.scale*treeScale.y;return 1===elementScaleX&&1===elementScaleY||(transform+=`scale(${elementScaleX}, ${elementScaleY})`),transform||"none"}const compareByDepth=(a,b)=>a.depth-b.depth;class FlatTree{constructor(){this.children=[],this.isDirty=!1}add(child){addUniqueItem(this.children,child),this.isDirty=!0}remove(child){removeItem(this.children,child),this.isDirty=!0}forEach(callback){this.isDirty&&this.children.sort(compareByDepth),this.isDirty=!1,this.children.forEach(callback)}}const transformAxes=["","X","Y","Z"];let create_projection_node_id=0;function createProjectionNode({attachResizeListener:attachResizeListener,defaultParent:defaultParent,measureScroll:measureScroll,checkIsScrollRoot:checkIsScrollRoot,resetTransform:resetTransform}){return class ProjectionNode{constructor(elementId,latestValues={},parent=(null==defaultParent?void 0:defaultParent())){this.id=create_projection_node_id++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isTransformDirty=!1,this.isProjectionDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.potentialNodes=new Map,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.nodes.forEach(propagateDirtyNodes),this.nodes.forEach(resolveTargetDelta),this.nodes.forEach(calcProjection)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.elementId=elementId,this.latestValues=latestValues,this.root=parent?parent.root||parent:this,this.path=parent?[...parent.path,parent]:[],this.parent=parent,this.depth=parent?parent.depth+1:0,elementId&&this.root.registerPotentialNode(elementId,this);for(let i=0;i<this.path.length;i++)this.path[i].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(name,handler){return this.eventHandlers.has(name)||this.eventHandlers.set(name,new SubscriptionManager),this.eventHandlers.get(name).add(handler)}notifyListeners(name,...args){const subscriptionManager=this.eventHandlers.get(name);null==subscriptionManager||subscriptionManager.notify(...args)}hasListeners(name){return this.eventHandlers.has(name)}registerPotentialNode(elementId,node){this.potentialNodes.set(elementId,node)}mount(instance,isLayoutDirty=!1){var _a;if(this.instance)return;this.isSVG=instance instanceof SVGElement&&"svg"!==instance.tagName,this.instance=instance;const{layoutId:layoutId,layout:layout,visualElement:visualElement}=this.options;if(visualElement&&!visualElement.current&&visualElement.mount(instance),this.root.nodes.add(this),null===(_a=this.parent)||void 0===_a||_a.children.add(this),this.elementId&&this.root.potentialNodes.delete(this.elementId),isLayoutDirty&&(layout||layoutId)&&(this.isLayoutDirty=!0),attachResizeListener){let cancelDelay;const resizeUnblockUpdate=()=>this.root.updateBlockedByResize=!1;attachResizeListener(instance,(()=>{this.root.updateBlockedByResize=!0,cancelDelay&&cancelDelay(),cancelDelay=delay(resizeUnblockUpdate,250),globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation))}))}layoutId&&this.root.registerSharedNode(layoutId,this),!1!==this.options.animate&&visualElement&&(layoutId||layout)&&this.addEventListener("didUpdate",(({delta:delta,hasLayoutChanged:hasLayoutChanged,hasRelativeTargetChanged:hasRelativeTargetChanged,layout:newLayout})=>{var _a,_b,_c,_d,_e;if(this.isTreeAnimationBlocked())return this.target=void 0,void(this.relativeTarget=void 0);const layoutTransition=null!==(_b=null!==(_a=this.options.transition)&&void 0!==_a?_a:visualElement.getDefaultTransition())&&void 0!==_b?_b:defaultLayoutTransition,{onLayoutAnimationStart:onLayoutAnimationStart,onLayoutAnimationComplete:onLayoutAnimationComplete}=visualElement.getProps(),targetChanged=!this.targetLayout||!boxEquals(this.targetLayout,newLayout)||hasRelativeTargetChanged,hasOnlyRelativeTargetChanged=!hasLayoutChanged&&hasRelativeTargetChanged;if((null===(_c=this.resumeFrom)||void 0===_c?void 0:_c.instance)||hasOnlyRelativeTargetChanged||hasLayoutChanged&&(targetChanged||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(delta,hasOnlyRelativeTargetChanged);const animationOptions={...getValueTransition(layoutTransition,"layout"),onPlay:onLayoutAnimationStart,onComplete:onLayoutAnimationComplete};visualElement.shouldReduceMotion&&(animationOptions.delay=0,animationOptions.type=!1),this.startAnimation(animationOptions)}else hasLayoutChanged||0!==this.animationProgress||finishAnimation(this),this.isLead()&&(null===(_e=(_d=this.options).onExitComplete)||void 0===_e||_e.call(_d));this.targetLayout=newLayout}))}unmount(){var _a,_b;this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this),null===(_a=this.getStack())||void 0===_a||_a.remove(this),null===(_b=this.parent)||void 0===_b||_b.children.delete(this),this.instance=void 0,es.qY.preRender(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){var _a;return this.isAnimationBlocked||(null===(_a=this.parent)||void 0===_a?void 0:_a.isTreeAnimationBlocked())||!1}startUpdate(){var _a;this.isUpdateBlocked()||(this.isUpdating=!0,null===(_a=this.nodes)||void 0===_a||_a.forEach(resetRotation),this.animationId++)}willUpdate(shouldNotifyListeners=!0){var _a,_b,_c;if(this.root.isUpdateBlocked())return void(null===(_b=(_a=this.options).onExitComplete)||void 0===_b||_b.call(_a));if(!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let i=0;i<this.path.length;i++){const node=this.path[i];node.shouldResetTransform=!0,node.updateScroll("snapshot")}const{layoutId:layoutId,layout:layout}=this.options;if(void 0===layoutId&&!layout)return;const transformTemplate=null===(_c=this.options.visualElement)||void 0===_c?void 0:_c.getProps().transformTemplate;this.prevTransformTemplateValue=null==transformTemplate?void 0:transformTemplate(this.latestValues,""),this.updateSnapshot(),shouldNotifyListeners&&this.notifyListeners("willUpdate")}didUpdate(){if(this.isUpdateBlocked())return this.unblockUpdate(),this.clearAllSnapshots(),void this.nodes.forEach(clearMeasurements);this.isUpdating&&(this.isUpdating=!1,this.potentialNodes.size&&(this.potentialNodes.forEach(mountNodeEarly),this.potentialNodes.clear()),this.nodes.forEach(resetTransformStyle),this.nodes.forEach(updateLayout),this.nodes.forEach(notifyLayoutUpdate),this.clearAllSnapshots(),es.iW.update(),es.iW.preRender(),es.iW.render())}clearAllSnapshots(){this.nodes.forEach(clearSnapshot),this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){es.ZP.preRender(this.updateProjection,!1,!0)}scheduleCheckAfterUnmount(){es.ZP.postRender((()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()}))}updateSnapshot(){!this.snapshot&&this.instance&&(this.snapshot=this.measure())}updateLayout(){var _a;if(!this.instance)return;if(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead()||this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let i=0;i<this.path.length;i++){this.path[i].updateScroll()}const prevLayout=this.layout;this.layout=this.measure(!1),this.layoutCorrected={x:{min:0,max:0},y:{min:0,max:0}},this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox),null===(_a=this.options.visualElement)||void 0===_a||_a.notify("LayoutMeasure",this.layout.layoutBox,null==prevLayout?void 0:prevLayout.layoutBox)}updateScroll(phase="measure"){let needsMeasurement=Boolean(this.options.layoutScroll&&this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===phase&&(needsMeasurement=!1),needsMeasurement&&(this.scroll={animationId:this.root.animationId,phase:phase,isRoot:checkIsScrollRoot(this.instance),offset:measureScroll(this.instance)})}resetTransform(){var _a;if(!resetTransform)return;const isResetRequested=this.isLayoutDirty||this.shouldResetTransform,hasProjection=this.projectionDelta&&!isDeltaZero(this.projectionDelta),transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate,transformTemplateValue=null==transformTemplate?void 0:transformTemplate(this.latestValues,""),transformTemplateHasChanged=transformTemplateValue!==this.prevTransformTemplateValue;isResetRequested&&(hasProjection||hasTransform(this.latestValues)||transformTemplateHasChanged)&&(resetTransform(this.instance,transformTemplateValue),this.shouldResetTransform=!1,this.scheduleRender())}measure(removeTransform=!0){const pageBox=this.measurePageBox();let layoutBox=this.removeElementScroll(pageBox);return removeTransform&&(layoutBox=this.removeTransform(layoutBox)),function roundBox(box){roundAxis(box.x),roundAxis(box.y)}(layoutBox),{animationId:this.root.animationId,measuredBox:pageBox,layoutBox:layoutBox,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:visualElement}=this.options;if(!visualElement)return{x:{min:0,max:0},y:{min:0,max:0}};const box=visualElement.measureViewportBox(),{scroll:scroll}=this.root;return scroll&&(translateAxis(box.x,scroll.offset.x),translateAxis(box.y,scroll.offset.y)),box}removeElementScroll(box){const boxWithoutScroll={x:{min:0,max:0},y:{min:0,max:0}};copyBoxInto(boxWithoutScroll,box);for(let i=0;i<this.path.length;i++){const node=this.path[i],{scroll:scroll,options:options}=node;if(node!==this.root&&scroll&&options.layoutScroll){if(scroll.isRoot){copyBoxInto(boxWithoutScroll,box);const{scroll:rootScroll}=this.root;rootScroll&&(translateAxis(boxWithoutScroll.x,-rootScroll.offset.x),translateAxis(boxWithoutScroll.y,-rootScroll.offset.y))}translateAxis(boxWithoutScroll.x,scroll.offset.x),translateAxis(boxWithoutScroll.y,scroll.offset.y)}}return boxWithoutScroll}applyTransform(box,transformOnly=!1){const withTransforms={x:{min:0,max:0},y:{min:0,max:0}};copyBoxInto(withTransforms,box);for(let i=0;i<this.path.length;i++){const node=this.path[i];!transformOnly&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(withTransforms,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),hasTransform(node.latestValues)&&transformBox(withTransforms,node.latestValues)}return hasTransform(this.latestValues)&&transformBox(withTransforms,this.latestValues),withTransforms}removeTransform(box){var _a;const boxWithoutTransform={x:{min:0,max:0},y:{min:0,max:0}};copyBoxInto(boxWithoutTransform,box);for(let i=0;i<this.path.length;i++){const node=this.path[i];if(!node.instance)continue;if(!hasTransform(node.latestValues))continue;hasScale(node.latestValues)&&node.updateSnapshot();const sourceBox={x:{min:0,max:0},y:{min:0,max:0}};copyBoxInto(sourceBox,node.measurePageBox()),removeBoxTransforms(boxWithoutTransform,node.latestValues,null===(_a=node.snapshot)||void 0===_a?void 0:_a.layoutBox,sourceBox)}return hasTransform(this.latestValues)&&removeBoxTransforms(boxWithoutTransform,this.latestValues),boxWithoutTransform}setTargetDelta(delta){this.targetDelta=delta,this.isProjectionDirty=!0,this.root.scheduleUpdateProjection()}setOptions(options){this.options={...this.options,...options,crossfade:void 0===options.crossfade||options.crossfade}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}resolveTargetDelta(){var _a;const lead=this.getLead();if(this.isProjectionDirty||(this.isProjectionDirty=lead.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=lead.isTransformDirty),!this.isProjectionDirty&&!this.attemptToResolveRelativeTarget)return;const{layout:layout,layoutId:layoutId}=this.options;if(this.layout&&(layout||layoutId)){if(!this.targetDelta&&!this.relativeTarget){const relativeParent=this.getClosestProjectingParent();relativeParent&&relativeParent.layout?(this.relativeParent=relativeParent,this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,relativeParent.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if((this.relativeTarget||this.targetDelta)&&(this.target||(this.target={x:{min:0,max:0},y:{min:0,max:0}},this.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}}),this.relativeTarget&&this.relativeTargetOrigin&&(null===(_a=this.relativeParent)||void 0===_a?void 0:_a.target)?function calcRelativeBox(target,relative,parent){calcRelativeAxis(target.x,relative.x,parent.x),calcRelativeAxis(target.y,relative.y,parent.y)}(this.target,this.relativeTarget,this.relativeParent.target):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):copyBoxInto(this.target,this.layout.layoutBox),applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget)){this.attemptToResolveRelativeTarget=!1;const relativeParent=this.getClosestProjectingParent();relativeParent&&Boolean(relativeParent.resumingFrom)===Boolean(this.resumingFrom)&&!relativeParent.options.layoutScroll&&relativeParent.target?(this.relativeParent=relativeParent,this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},calcRelativePosition(this.relativeTargetOrigin,this.target,relativeParent.target),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}}}getClosestProjectingParent(){if(this.parent&&!hasScale(this.parent.latestValues)&&!has2DTranslate(this.parent.latestValues))return(this.parent.relativeTarget||this.parent.targetDelta)&&this.parent.layout?this.parent:this.parent.getClosestProjectingParent()}calcProjection(){var _a;const{isProjectionDirty:isProjectionDirty,isTransformDirty:isTransformDirty}=this;this.isProjectionDirty=this.isTransformDirty=!1;const lead=this.getLead(),isShared=Boolean(this.resumingFrom)||this!==lead;let canSkip=!0;if(isProjectionDirty&&(canSkip=!1),isShared&&isTransformDirty&&(canSkip=!1),canSkip)return;const{layout:layout,layoutId:layoutId}=this.options;if(this.isTreeAnimating=Boolean((null===(_a=this.parent)||void 0===_a?void 0:_a.isTreeAnimating)||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!layout&&!layoutId)return;copyBoxInto(this.layoutCorrected,this.layout.layoutBox),function applyTreeDeltas(box,treeScale,treePath,isSharedTransition=!1){var _a,_b;const treeLength=treePath.length;if(!treeLength)return;let node,delta;treeScale.x=treeScale.y=1;for(let i=0;i<treeLength;i++)node=treePath[i],delta=node.projectionDelta,"contents"!==(null===(_b=null===(_a=node.instance)||void 0===_a?void 0:_a.style)||void 0===_b?void 0:_b.display)&&(isSharedTransition&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(box,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),delta&&(treeScale.x*=delta.x.scale,treeScale.y*=delta.y.scale,applyBoxDelta(box,delta)),isSharedTransition&&hasTransform(node.latestValues)&&transformBox(box,node.latestValues));treeScale.x=snapToDefault(treeScale.x),treeScale.y=snapToDefault(treeScale.y)}(this.layoutCorrected,this.treeScale,this.path,isShared);const{target:target}=lead;if(!target)return;this.projectionDelta||(this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDeltaWithTransform={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}});const prevTreeScaleX=this.treeScale.x,prevTreeScaleY=this.treeScale.y,prevProjectionTransform=this.projectionTransform;calcBoxDelta(this.projectionDelta,this.layoutCorrected,target,this.latestValues),this.projectionTransform=buildProjectionTransform(this.projectionDelta,this.treeScale),this.projectionTransform===prevProjectionTransform&&this.treeScale.x===prevTreeScaleX&&this.treeScale.y===prevTreeScaleY||(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",target))}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(notifyAll=!0){var _a,_b,_c;null===(_b=(_a=this.options).scheduleRender)||void 0===_b||_b.call(_a),notifyAll&&(null===(_c=this.getStack())||void 0===_c||_c.scheduleRender()),this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(delta,hasOnlyRelativeTargetChanged=!1){var _a,_b;const snapshot=this.snapshot,snapshotLatestValues=(null==snapshot?void 0:snapshot.latestValues)||{},mixedValues={...this.latestValues},targetDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};this.relativeTarget=this.relativeTargetOrigin=void 0,this.attemptToResolveRelativeTarget=!hasOnlyRelativeTargetChanged;const relativeLayout={x:{min:0,max:0},y:{min:0,max:0}},isSharedLayoutAnimation=(null==snapshot?void 0:snapshot.source)!==(null===(_a=this.layout)||void 0===_a?void 0:_a.source),isOnlyMember=((null===(_b=this.getStack())||void 0===_b?void 0:_b.members.length)||0)<=1,shouldCrossfadeOpacity=Boolean(isSharedLayoutAnimation&&!isOnlyMember&&!0===this.options.crossfade&&!this.path.some(hasOpacityCrossfade));this.animationProgress=0,this.mixTargetDelta=latest=>{var _a;const progress=latest/1e3;mixAxisDelta(targetDelta.x,delta.x,progress),mixAxisDelta(targetDelta.y,delta.y,progress),this.setTargetDelta(targetDelta),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&(null===(_a=this.relativeParent)||void 0===_a?void 0:_a.layout)&&(calcRelativePosition(relativeLayout,this.layout.layoutBox,this.relativeParent.layout.layoutBox),function mixBox(output,from,to,p){mixAxis(output.x,from.x,to.x,p),mixAxis(output.y,from.y,to.y,p)}(this.relativeTarget,this.relativeTargetOrigin,relativeLayout,progress)),isSharedLayoutAnimation&&(this.animationValues=mixedValues,function mixValues(target,follow,lead,progress,shouldCrossfadeOpacity,isOnlyMember){var _a,_b,_c,_d;shouldCrossfadeOpacity?(target.opacity=mix(0,null!==(_a=lead.opacity)&&void 0!==_a?_a:1,easeCrossfadeIn(progress)),target.opacityExit=mix(null!==(_b=follow.opacity)&&void 0!==_b?_b:1,0,easeCrossfadeOut(progress))):isOnlyMember&&(target.opacity=mix(null!==(_c=follow.opacity)&&void 0!==_c?_c:1,null!==(_d=lead.opacity)&&void 0!==_d?_d:1,progress));for(let i=0;i<numBorders;i++){const borderLabel=`border${borders[i]}Radius`;let followRadius=getRadius(follow,borderLabel),leadRadius=getRadius(lead,borderLabel);void 0===followRadius&&void 0===leadRadius||(followRadius||(followRadius=0),leadRadius||(leadRadius=0),0===followRadius||0===leadRadius||isPx(followRadius)===isPx(leadRadius)?(target[borderLabel]=Math.max(mix(asNumber(followRadius),asNumber(leadRadius),progress),0),(percent.test(leadRadius)||percent.test(followRadius))&&(target[borderLabel]+="%")):target[borderLabel]=leadRadius)}(follow.rotate||lead.rotate)&&(target.rotate=mix(follow.rotate||0,lead.rotate||0,progress))}(mixedValues,snapshotLatestValues,this.latestValues,progress,shouldCrossfadeOpacity,isOnlyMember)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=progress},this.mixTargetDelta(0)}startAnimation(options){var _a,_b;this.notifyListeners("animationStart"),null===(_a=this.currentAnimation)||void 0===_a||_a.stop(),this.resumingFrom&&(null===(_b=this.resumingFrom.currentAnimation)||void 0===_b||_b.stop()),this.pendingAnimation&&(es.qY.update(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=es.ZP.update((()=>{globalProjectionState.hasAnimatedSinceResize=!0,this.currentAnimation=function animate_animate(from,to,transition={}){const value=isMotionValue(from)?from:motionValue(from);return startAnimation("",value,to,transition),{stop:()=>value.stop(),isAnimating:()=>value.isAnimating()}}(0,1e3,{...options,onUpdate:latest=>{var _a;this.mixTargetDelta(latest),null===(_a=options.onUpdate)||void 0===_a||_a.call(options,latest)},onComplete:()=>{var _a;null===(_a=options.onComplete)||void 0===_a||_a.call(options),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0}))}completeAnimation(){var _a;this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0),null===(_a=this.getStack())||void 0===_a||_a.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){var _a;this.currentAnimation&&(null===(_a=this.mixTargetDelta)||void 0===_a||_a.call(this,1e3),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const lead=this.getLead();let{targetWithTransforms:targetWithTransforms,target:target,layout:layout,latestValues:latestValues}=lead;if(targetWithTransforms&&target&&layout){if(this!==lead&&this.layout&&layout&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,layout.layoutBox)){target=this.target||{x:{min:0,max:0},y:{min:0,max:0}};const xLength=calcLength(this.layout.layoutBox.x);target.x.min=lead.target.x.min,target.x.max=target.x.min+xLength;const yLength=calcLength(this.layout.layoutBox.y);target.y.min=lead.target.y.min,target.y.max=target.y.min+yLength}copyBoxInto(targetWithTransforms,target),transformBox(targetWithTransforms,latestValues),calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,targetWithTransforms,latestValues)}}registerSharedNode(layoutId,node){var _a,_b,_c;this.sharedNodes.has(layoutId)||this.sharedNodes.set(layoutId,new NodeStack);this.sharedNodes.get(layoutId).add(node),node.promote({transition:null===(_a=node.options.initialPromotionConfig)||void 0===_a?void 0:_a.transition,preserveFollowOpacity:null===(_c=null===(_b=node.options.initialPromotionConfig)||void 0===_b?void 0:_b.shouldPreserveFollowOpacity)||void 0===_c?void 0:_c.call(_b,node)})}isLead(){const stack=this.getStack();return!stack||stack.lead===this}getLead(){var _a;const{layoutId:layoutId}=this.options;return layoutId&&(null===(_a=this.getStack())||void 0===_a?void 0:_a.lead)||this}getPrevLead(){var _a;const{layoutId:layoutId}=this.options;return layoutId?null===(_a=this.getStack())||void 0===_a?void 0:_a.prevLead:void 0}getStack(){const{layoutId:layoutId}=this.options;if(layoutId)return this.root.sharedNodes.get(layoutId)}promote({needsReset:needsReset,transition:transition,preserveFollowOpacity:preserveFollowOpacity}={}){const stack=this.getStack();stack&&stack.promote(this,preserveFollowOpacity),needsReset&&(this.projectionDelta=void 0,this.needsReset=!0),transition&&this.setOptions({transition:transition})}relegate(){const stack=this.getStack();return!!stack&&stack.relegate(this)}resetRotation(){const{visualElement:visualElement}=this.options;if(!visualElement)return;let hasRotate=!1;const{latestValues:latestValues}=visualElement;if((latestValues.rotate||latestValues.rotateX||latestValues.rotateY||latestValues.rotateZ)&&(hasRotate=!0),!hasRotate)return;const resetValues={};for(let i=0;i<transformAxes.length;i++){const key="rotate"+transformAxes[i];latestValues[key]&&(resetValues[key]=latestValues[key],visualElement.setStaticValue(key,0))}null==visualElement||visualElement.render();for(const key in resetValues)visualElement.setStaticValue(key,resetValues[key]);visualElement.scheduleRender()}getProjectionStyles(styleProp={}){var _a,_b,_c;const styles={};if(!this.instance||this.isSVG)return styles;if(!this.isVisible)return{visibility:"hidden"};styles.visibility="";const transformTemplate=null===(_a=this.options.visualElement)||void 0===_a?void 0:_a.getProps().transformTemplate;if(this.needsReset)return this.needsReset=!1,styles.opacity="",styles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||"",styles.transform=transformTemplate?transformTemplate(this.latestValues,""):"none",styles;const lead=this.getLead();if(!this.projectionDelta||!this.layout||!lead.target){const emptyStyles={};return this.options.layoutId&&(emptyStyles.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,emptyStyles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||""),this.hasProjected&&!hasTransform(this.latestValues)&&(emptyStyles.transform=transformTemplate?transformTemplate({},""):"none",this.hasProjected=!1),emptyStyles}const valuesToRender=lead.animationValues||lead.latestValues;this.applyTransformsToTarget(),styles.transform=buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,valuesToRender),transformTemplate&&(styles.transform=transformTemplate(valuesToRender,styles.transform));const{x:x,y:y}=this.projectionDelta;styles.transformOrigin=`${100*x.origin}% ${100*y.origin}% 0`,lead.animationValues?styles.opacity=lead===this?null!==(_c=null!==(_b=valuesToRender.opacity)&&void 0!==_b?_b:this.latestValues.opacity)&&void 0!==_c?_c:1:this.preserveOpacity?this.latestValues.opacity:valuesToRender.opacityExit:styles.opacity=lead===this?void 0!==valuesToRender.opacity?valuesToRender.opacity:"":void 0!==valuesToRender.opacityExit?valuesToRender.opacityExit:0;for(const key in scaleCorrectors){if(void 0===valuesToRender[key])continue;const{correct:correct,applyTo:applyTo}=scaleCorrectors[key],corrected=correct(valuesToRender[key],lead);if(applyTo){const num=applyTo.length;for(let i=0;i<num;i++)styles[applyTo[i]]=corrected}else styles[key]=corrected}return this.options.layoutId&&(styles.pointerEvents=lead===this?resolveMotionValue(styleProp.pointerEvents)||"":"none"),styles}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach((node=>{var _a;return null===(_a=node.currentAnimation)||void 0===_a?void 0:_a.stop()})),this.root.nodes.forEach(clearMeasurements),this.root.sharedNodes.clear()}}}function updateLayout(node){node.updateLayout()}function notifyLayoutUpdate(node){var _a,_b,_c;const snapshot=(null===(_a=node.resumeFrom)||void 0===_a?void 0:_a.snapshot)||node.snapshot;if(node.isLead()&&node.layout&&snapshot&&node.hasListeners("didUpdate")){const{layoutBox:layout,measuredBox:measuredLayout}=node.layout,{animationType:animationType}=node.options,isShared=snapshot.source!==node.layout.source;"size"===animationType?eachAxis((axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(axisSnapshot);axisSnapshot.min=layout[axis].min,axisSnapshot.max=axisSnapshot.min+length})):shouldAnimatePositionOnly(animationType,snapshot.layoutBox,layout)&&eachAxis((axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(layout[axis]);axisSnapshot.max=axisSnapshot.min+length}));const layoutDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};calcBoxDelta(layoutDelta,layout,snapshot.layoutBox);const visualDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};isShared?calcBoxDelta(visualDelta,node.applyTransform(measuredLayout,!0),snapshot.measuredBox):calcBoxDelta(visualDelta,layout,snapshot.layoutBox);const hasLayoutChanged=!isDeltaZero(layoutDelta);let hasRelativeTargetChanged=!1;if(!node.resumeFrom){const relativeParent=node.getClosestProjectingParent();if(relativeParent&&!relativeParent.resumeFrom){const{snapshot:parentSnapshot,layout:parentLayout}=relativeParent;if(parentSnapshot&&parentLayout){const relativeSnapshot={x:{min:0,max:0},y:{min:0,max:0}};calcRelativePosition(relativeSnapshot,snapshot.layoutBox,parentSnapshot.layoutBox);const relativeLayout={x:{min:0,max:0},y:{min:0,max:0}};calcRelativePosition(relativeLayout,layout,parentLayout.layoutBox),boxEquals(relativeSnapshot,relativeLayout)||(hasRelativeTargetChanged=!0)}}}node.notifyListeners("didUpdate",{layout:layout,snapshot:snapshot,delta:visualDelta,layoutDelta:layoutDelta,hasLayoutChanged:hasLayoutChanged,hasRelativeTargetChanged:hasRelativeTargetChanged})}else node.isLead()&&(null===(_c=(_b=node.options).onExitComplete)||void 0===_c||_c.call(_b));node.options.transition=void 0}function propagateDirtyNodes(node){node.isProjectionDirty||(node.isProjectionDirty=Boolean(node.parent&&node.parent.isProjectionDirty)),node.isTransformDirty||(node.isTransformDirty=Boolean(node.parent&&node.parent.isTransformDirty))}function clearSnapshot(node){node.clearSnapshot()}function clearMeasurements(node){node.clearMeasurements()}function resetTransformStyle(node){const{visualElement:visualElement}=node.options;(null==visualElement?void 0:visualElement.getProps().onBeforeLayoutMeasure)&&visualElement.notify("BeforeLayoutMeasure"),node.resetTransform()}function finishAnimation(node){node.finishAnimation(),node.targetDelta=node.relativeTarget=node.target=void 0}function resolveTargetDelta(node){node.resolveTargetDelta()}function calcProjection(node){node.calcProjection()}function resetRotation(node){node.resetRotation()}function removeLeadSnapshots(stack){stack.removeLeadSnapshot()}function mixAxisDelta(output,delta,p){output.translate=mix(delta.translate,0,p),output.scale=mix(delta.scale,1,p),output.origin=delta.origin,output.originPoint=delta.originPoint}function mixAxis(output,from,to,p){output.min=mix(from.min,to.min,p),output.max=mix(from.max,to.max,p)}function hasOpacityCrossfade(node){return node.animationValues&&void 0!==node.animationValues.opacityExit}const defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]};function mountNodeEarly(node,elementId){let searchNode=node.root;for(let i=node.path.length-1;i>=0;i--)if(Boolean(node.path[i].instance)){searchNode=node.path[i];break}const element=(searchNode&&searchNode!==node.root?searchNode.instance:document).querySelector(`[data-projection-id="${elementId}"]`);element&&node.mount(element,!0)}function roundAxis(axis){axis.min=Math.round(axis.min),axis.max=Math.round(axis.max)}function shouldAnimatePositionOnly(animationType,snapshot,layout){return"position"===animationType||"preserve-aspect"===animationType&&!isNear(aspectRatio(snapshot),aspectRatio(layout),.2)}const DocumentProjectionNode=createProjectionNode({attachResizeListener:(ref,notify)=>addDomEvent(ref,"resize",notify),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode_HTMLProjectionNode=createProjectionNode({measureScroll:instance=>({x:instance.scrollLeft,y:instance.scrollTop}),defaultParent:()=>{if(!rootProjectionNode.current){const documentNode=new DocumentProjectionNode(0,{});documentNode.mount(window),documentNode.setOptions({layoutScroll:!0}),rootProjectionNode.current=documentNode}return rootProjectionNode.current},resetTransform:(instance,value)=>{instance.style.transform=void 0!==value?value:"none"},checkIsScrollRoot:instance=>Boolean("fixed"===window.getComputedStyle(instance).position)}),featureBundle={...animations,...gestureAnimations,...drag,...layoutFeatures},motion=createMotionProxy(((Component,config)=>function create_config_createDomMotionConfig(Component,{forwardMotionProps:forwardMotionProps=!1},preloadedFeatures,createVisualElement,projectionNodeConstructor){return{...isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig,preloadedFeatures:preloadedFeatures,useRender:createUseRender(forwardMotionProps),createVisualElement:createVisualElement,projectionNodeConstructor:projectionNodeConstructor,Component:Component}}(Component,config,featureBundle,create_visual_element_createDomVisualElement,HTMLProjectionNode_HTMLProjectionNode)))},"./node_modules/framer-motion/dist/es/utils/is-browser.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{j:function(){return isBrowser}});const isBrowser="undefined"!=typeof document},"./node_modules/framer-motion/dist/es/utils/process.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{O:function(){return env}});var process=__webpack_require__("./node_modules/process/browser.js");const env=(void 0===process||process.env,"production")},"./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{A:function(){return initPrefersReducedMotion}});var _is_browser_mjs__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/framer-motion/dist/es/utils/is-browser.mjs"),_state_mjs__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs");function initPrefersReducedMotion(){if(_state_mjs__WEBPACK_IMPORTED_MODULE_0__.O.current=!0,_is_browser_mjs__WEBPACK_IMPORTED_MODULE_1__.j)if(window.matchMedia){const motionMediaQuery=window.matchMedia("(prefers-reduced-motion)"),setReducedMotionPreferences=()=>_state_mjs__WEBPACK_IMPORTED_MODULE_0__.n.current=motionMediaQuery.matches;motionMediaQuery.addListener(setReducedMotionPreferences),setReducedMotionPreferences()}else _state_mjs__WEBPACK_IMPORTED_MODULE_0__.n.current=!1}},"./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{O:function(){return hasReducedMotionListener},n:function(){return prefersReducedMotion}});const prefersReducedMotion={current:null},hasReducedMotionListener={current:!1}},"./node_modules/framer-motion/dist/es/utils/use-constant.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{h:function(){return useConstant}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");function useConstant(init){const ref=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);return null===ref.current&&(ref.current=init()),ref.current}},"./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{L:function(){return useIsomorphicLayoutEffect}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");const useIsomorphicLayoutEffect=__webpack_require__("./node_modules/framer-motion/dist/es/utils/is-browser.mjs").j?react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect:react__WEBPACK_IMPORTED_MODULE_0__.useEffect},"./node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{z:function(){return useUnmountEffect}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");function useUnmountEffect(callback){return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>()=>callback()),[])}},"./node_modules/framer-motion/dist/es/utils/warn-once.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{O:function(){return warnOnce}});const warned=new Set;function warnOnce(condition,message,element){condition||warned.has(message)||(console.warn(message),element&&console.warn(element),warned.add(message))}},"./node_modules/framesync/dist/es/index.mjs":function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{qY:function(){return cancelSync},ZP:function(){return es},iW:function(){return flushSync},$B:function(){return getFrameData}});const getCurrentTime="undefined"!=typeof performance?()=>performance.now():()=>Date.now(),onNextFrame="undefined"!=typeof window?callback=>window.requestAnimationFrame(callback):callback=>setTimeout((()=>callback(getCurrentTime())),16.666666666666668);let useDefaultElapsed=!0,runNextFrame=!1,isProcessing=!1;const es_frame={delta:0,timestamp:0},stepsOrder=["read","update","preRender","render","postRender"],steps=stepsOrder.reduce(((acc,key)=>(acc[key]=function createRenderStep(runNextFrame){let toRun=[],toRunNextFrame=[],numToRun=0,isProcessing=!1,flushNextFrame=!1;const toKeepAlive=new WeakSet,step={schedule:(callback,keepAlive=!1,immediate=!1)=>{const addToCurrentFrame=immediate&&isProcessing,buffer=addToCurrentFrame?toRun:toRunNextFrame;return keepAlive&&toKeepAlive.add(callback),-1===buffer.indexOf(callback)&&(buffer.push(callback),addToCurrentFrame&&isProcessing&&(numToRun=toRun.length)),callback},cancel:callback=>{const index=toRunNextFrame.indexOf(callback);-1!==index&&toRunNextFrame.splice(index,1),toKeepAlive.delete(callback)},process:frameData=>{if(isProcessing)flushNextFrame=!0;else{if(isProcessing=!0,[toRun,toRunNextFrame]=[toRunNextFrame,toRun],toRunNextFrame.length=0,numToRun=toRun.length,numToRun)for(let i=0;i<numToRun;i++){const callback=toRun[i];callback(frameData),toKeepAlive.has(callback)&&(step.schedule(callback),runNextFrame())}isProcessing=!1,flushNextFrame&&(flushNextFrame=!1,step.process(frameData))}}};return step}((()=>runNextFrame=!0)),acc)),{}),sync=stepsOrder.reduce(((acc,key)=>{const step=steps[key];return acc[key]=(process,keepAlive=!1,immediate=!1)=>(runNextFrame||startLoop(),step.schedule(process,keepAlive,immediate)),acc}),{}),cancelSync=stepsOrder.reduce(((acc,key)=>(acc[key]=steps[key].cancel,acc)),{}),flushSync=stepsOrder.reduce(((acc,key)=>(acc[key]=()=>steps[key].process(es_frame),acc)),{}),processStep=stepId=>steps[stepId].process(es_frame),processFrame=timestamp=>{runNextFrame=!1,es_frame.delta=useDefaultElapsed?16.666666666666668:Math.max(Math.min(timestamp-es_frame.timestamp,40),1),es_frame.timestamp=timestamp,isProcessing=!0,stepsOrder.forEach(processStep),isProcessing=!1,runNextFrame&&(useDefaultElapsed=!1,onNextFrame(processFrame))},startLoop=()=>{runNextFrame=!0,useDefaultElapsed=!0,isProcessing||onNextFrame(processFrame)},getFrameData=()=>es_frame;var es=sync}}]);